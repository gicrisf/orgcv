#+title: Org CV
#+author: Giovanni Crisalfi
#+date: [2022-08-31 mer]
#+startup: overview

# How to export this file?
# =org-export-dispatch= for some reason ignores the =latex= blocks but exports the =tex= ones;
# A quick solution is to replace =latex= with =tex= when we want to export
# (with vim substitute command, use this regex: =%s/\s\<latex\C/ tex/g=
# Then uncomment the line below to disable the block evaluation (it will be faster too)
# #+PROPERTY: header-args :eval never-export
# Finally, undo the command to restore the =latex= keyword in the src blocks
# Enjoy the exported files

#+hugo_base_dir: ~/zwitterio-it/
#+hugo_section: orgcv
#+hugo_categories: projects software
#+hugo_tags: emacs org python
#+hugo_auto_set_lastmod: t
#+export_file_name: index.en.md

#+MACRO: more @@html:<!-- more -->@@

# Questo file raccoglie tutto il codice necessario a generare il mio CV nelle sue varie versioni.
# È anche un esempio di literate programming in org-mode.

This file sums up all the necessary code to generate my CV in all its versions.
Moreover, it's an example of literate programming in org-mode.

{{{more}}}

* Quickstart
Just run those blocks to set up the Python environment and importing the libraries, then you can tangle the files you need.

Is this your first time here? You need to create a virtual environment. If you trust me, you can launch the scripted installation from the next block:
#+begin_src bash :session cv-venv :noweb no-export :results output silent
python venvomatic.py
#+end_src

Now that you have perfectly working virtual environment, activate it:
#+begin_src emacs-lisp :noweb no-export :session cv-venv :results output silent :var path=full-path-venv()
(pyvenv-activate path)
#+end_src

Import the dependencies in this session:
#+begin_src python :noweb no-export :session cv-venv :results output silent
<<trying-importing-python-libs>>
#+end_src

Create an environment for Jinja2:
#+begin_src python :noweb no-export :session cv-venv :results output silent
<<create-jinja-env>>
#+end_src

Read the results in the minibuffer. If it's a success, you're good to go.
If you're interested in what this is about (or you got some errors), just read the "Python environment" section, that explains everything step by step.

* Intro
I'm writing this because I was using another org-mode method to manage my CV which is too interlaced with the LaTeX syntax and relies too much on org macros.
Although that method was effective for managing a single CV in LaTeX and had a lot of advantages, I wanted something more solid and modular.
Particurarly, I wanted to decouple the data insertion and the markup writing, both in LaTeX or in other languages like HTML/Markdown and so on.
So, I have three section to write down:
- This introduction, with some explainings about the environment we're going to use;
- The section that will collect the data;
- The section that will collect the templates for rendering the data and exporting them to other formats.

First of all, I have to make some decisions. I have to choose how to maintain the data and the templates: the options are *a lot*.
I don't love the idea to write stuff in JSON, because it's difficult to read, it's impossible to comment out the lines or adding actual comments around the text.
Of course we could collect the JSON chunks here in org-mode and write all around the blocks, but org-babel doesn't have actual support for JSON and the commenting-out part of the problem remains.
It would be better writing TOML or YAML, maybe, but my mind goes to those other solutions:
- Python dictionaries;
- Elisp association lists (alists);

# Innanzitutto devo rappresentare in qualche modo i dati da riportare nei codici da intessere nelle parti successive. Ho molte opzioni. In JSON non se ne parla proprio. Sarebbe già più accettabile scrivere in TOML, ma in verità le opzioni che mi convincono di più sono due:
# - Python dictionaries
# - Elisp association lists

The first ones for their simplicity, readability, good integration with org-babel and extensibility (every dictionary can be manipulated dynamically from other python functions inside the block).
The second ones would be lovely for their perfect integration with org-babel and Emacs in general.
# Il primo per la sua semplicità, potenziale estensibilità (ogni dato scritto può essere manipolato dagli altri presenti all'interno del blocco, come con la configurazione di Pelican) e buona integrazione con org-babel. Il secondo per l'integrazione assoluta con org-babel ed Emacs in generale.

Let's keep those potential solutions in mind for a bit and let's take a look on the next part: the templating problem.
The idea consists on collecting modular blocks of data, in order to export different versions of the same CV. We could keep the same header, for example, or, however, we could share certain blocks without writing redundant code. Writing Python dictionaries, I could inject my data in the LaTeX text at least in three ways:
- Classical string manipulation;
- Templating engine (Jinja2 is the one that comes up to my mind because it's powerful and I already know it);
- Through PyLaTeX.

# L'idea è quella di collezionare blocchi di dati modulari, così da esportare varie versioni dello stesso CV con lo stesso Header, per esempio o, comunque, condividendo certi blocchi di dati senza ridondanze di sorta. Scrivendo dizionari Python, potrei iniettare i dati nel testo LaTeX in almeno tre modi:
# - Manipolazione delle stringhe classica
# - Motore di templating (Jinja2, per esempio, ma questo mi costringerebbe ad avere dipendenze)
# - Attraverso PyLaTeX (ma, anche qui, dovrei disporre della dipendenza)

In the last two cases we should depend on two external libraries, but it wouldn't be a real problem, especially in Python, because the priority is to maintain the maximum flexibility with a good amount of portability.

# Avere dipendenze esterne non è un grave problema, soprattutto in Python, ma vorrei mantenere questo file quanto più flessibile possibile.
Moreover, Jinja2 could help me with the internationalization (through Babel), so I think it's worth the risk.
# Il bello di Jinja2 è che potrebbe aiutarmi a gestire l'internazionalizzazione (con Babel), quindi credo che il gioco valga la candela.
I could achieve the same results with emacs-lisp, but I think it would be less practical and readable.
Not because of the data collecting, which is fine, but for the templating part.
# Potrei ottenere le stesse cose in emacs-lisp, ma temo che risulterebbero meno leggibili.

# Inoltre, con Jinja2 posso facilmente esportare anche delle pagine HTML e sarebbe molto molto semplice gestire i for loops, cosa che mi tornerà utile per ripetere gli stessi template su progetti, lingue ecc. su tutte le versioni del CV (LaTeX, HTML, Markdown...). Considerate tutte queste premesse, non c'è dubbio che un motore di templating sia esattamente quello che ci serve in questa situazione per mantenere il codice leggibile e flessibile.
Considering all this introduction, I think the templating engine is the right choice and that it would be exactly the tool we need in this situation. Basically, we're about to make a CV generator, all inside an org-mode file.

* Python environment
# Non ci resta che costruire un ambiente Python adatto.
Now, we just have to build the right Python environment.

#+begin_comment
ATTENZIONE!

Per i più disattenti, il CV non può essere renderizzato senza alcune piccole dipendenze Python.
#+end_comment

#+begin_quote
ALERT!

I write this for the distracted ones: the CV cannot be rendered without some Python dependencies.
#+end_quote

# Come si installa Jinja2?

How should one install Jinja2?

# [[https://jinja.palletsprojects.com/en/3.1.x/intro/#installation][Basta dare un occhio alla documentazione]].

** Global installation
# Usare un [[https://packaging.python.org/tutorials/installing-packages/#creating-virtual-environments][virtual environment]] è preferibile, ma installare globalmente è più semplice:

A virtual environment is better in the long run, but installing globally is easier:

#+begin_src bash
$ pip install Jinja2
#+end_src

# Per il supporto multilingua, bisogna anche installare Babel, che non è automaticamente incluso tra le dipendenze.

To gain a multilang support, we should install Babel too, which isn't automatically included in the dependencies.

#+begin_src bash
$ pip install Babel
#+end_src

# Io preferisco usare un virtual environment, ma lascio comunque qui i comandi base per chi volesse semplificarsi la vita.

As previously said, I prefer using a virtual environment, but I leave the basic commands up her for anyone else who could prefer them.

** Create a virtualenv
# In condizioni normali, questo è quello che faremmo per creare un virtual environment (chiamato =venv=).
Outside Emacs, that's what we usually would do to create a virtual environment (or a =venv=).

First of all, go to your preferred directory (e.g. =~/.venvs/cv-venv=); then,

#+begin_src bash
$ mkdir myproject
$ cd myproject
$ virtualenv venv
New python executable in venv/bin/python
Installing distribute............done.
#+end_src

# Questo per attivarlo:
This command to activate:
#+begin_src bash
$ source venv/bin/activate
#+end_src

Why =source=? [[https://groups.google.com/g/python-virtualenv/c/FfipsFBqvq4/m/gcEujM43YQ4J][Because]].

#+begin_quote
The activate script actually modifies your shell environment, so you can't use it like a normal command.
#+end_quote

# Anziché attivarlo, limitiamoci a creare un virtual environment inequivocabilmente utile alla produzione del CV e lasciamolo in attesa.
# In this case, instead of activating it, we should just create the virtual environment and make it rest, waiting for us to evoke it.

Now, install the requirements like we did before:

#+begin_src bash
$ pip install Jinja2
$ pip install Babel
#+end_src

# If you want to go faster, install them with a single command from the =requirements.txt= file in this repo:

#+name: python-requirements
#+begin_comment txt :tangle requirements.txt
Jinja2
Babel
#+end_comment

# Install easily with pip:
#+begin_comment bash
$ pip install ./requirements.txt
#+end_comment

If you want to go even faster, I scripted the process in the next block to obtain the same result.

** Scripting the virtualenv generation
If you don't like to do stuff the good ol' way and you want me to do all that automatically, there's a script for you.
# we will need a pretty package before.
# In Arch-based systems:

#+begin_comment
(src)
$ sudo pacman -S python-pipenv
#+end_comment

# [[https://pipenv.pypa.io/en/latest/][Look here for installing in other systems]].

# TODO Use pipenv + Pipfile
# We could install everything with subprocess, but it would be harder to manage the permission errors that are likely to happen.

You can launch the =venvomatic.py= script both from the terminal emulator (you find the file in the repo directory), or directly executing this block from here. If you don't like the presets, change the directories for your venv first. Otherwise, pass over and execute the block directly.

#+name: parent-directory-venv
#+begin_src python
# Relative to the home folder
parent_directory = ".venvs"
return(parent_directory)
#+end_src

The subdiherer of our virtual environment:
#+name: new-directory-venv
#+begin_src python
# Relative to the parent folder
new_venv_directory = "cv-venv"
return(new_venv_directory)
#+end_src

The actual script:
# Tangled to
# :tangle venvomatic.py
#+name: venv-o-matic
#+begin_src python :results output :var parent_dir=parent-directory-venv() :var new_dir=new-directory-venv()
import virtualenv
import os
import subprocess

# Where we want to put our virtual environment
if parent_dir:
    venvs_dir = os.path.join(os.path.expanduser("~"), parent_dir)
else:
    venvs_dir = os.path.join(os.path.expanduser("~"), ".venvs")

# Make the parent directory if it doesn't exists
if not os.path.exists(venvs_dir):
    os.makedirs(venvs_dir)
    print("{} not found; made it.".format(venvs_dir))

# Choose a specific directory to be made
if new_dir:
    cv_venv_dir = os.path.join(venvs_dir, new_dir)
else:
    cv_venv_dir = os.path.join(venvs_dir, "cv-venv")

# Make the parent directory if it doesn't exists
if not os.path.exists(cv_venv_dir):
    os.makedirs(cv_venv_dir)
    print("{} not found; made it.".format(cv_venv_dir))

# Create the new venv
# virtualenv.create_environment(cv_venv_dir) # deprecated
print("creating the new venv...")
subprocess.run(["python", "-m", "venv", cv_venv_dir]) # use venv instead
print("done.")

# Find the new executable
py_binary = os.path.join(cv_venv_dir, "bin")

os.chdir(cv_venv_dir)

# Install requirements
print("installing requirements...")
subprocess.Popen(["./python", "-m", "pip", "install", "-U", "Jinja2", "Babel"], cwd=py_binary)
print("done.")
print("now exiting.")
#+end_src

#+RESULTS: venv-o-matic
#+begin_example
/home/cromo/.venvs not found; made it.
/home/cromo/.venvs/cv-venv not found; made it.
creating the new venv...
done.
installing requirements...
done.
now exiting.
Collecting Jinja2
  Using cached Jinja2-3.1.2-py3-none-any.whl (133 kB)
Collecting Babel
  Using cached Babel-2.10.3-py3-none-any.whl (9.5 MB)
Collecting MarkupSafe>=2.0
  Using cached MarkupSafe-2.1.1-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (25 kB)
Collecting pytz>=2015.7
  Using cached pytz-2022.2.1-py2.py3-none-any.whl (500 kB)
Installing collected packages: pytz, MarkupSafe, Babel, Jinja2
Successfully installed Babel-2.10.3 Jinja2-3.1.2 MarkupSafe-2.1.1 pytz-2022.2.1
#+end_example

# The output you should see something like this.

** Virtualenv inside Emacs
In Emacs, things get a little more convoluted.
# In Emacs le cose si fanno un po' più complicate.

From StackOverlow:
# Da StackOverlow:
- [[https://stackoverflow.com/questions/38535499/how-to-setup-emacs-to-use-a-given-python-virtualenv][How to setup Emacs to use a given Python virtualenv?]]
- [[https://stackoverflow.com/questions/53992886/org-babel-python-environment-setup][org-babel python environment setup]]

# Anche sulla base di [[https://justin.abrah.ms/dotfiles/emacs.html][alcune literate conf di Emacs]], pare che l'opzione più quotata sia utilizzare un pacchetto Emacs che fa da tramite, [[https://github.com/jorgenschaefer/pyvenv][pyvenv]].

The more appreciated approach looks like the one with =pyvenv=.

#+begin_quote
The main entry points are pyvenv-activate, which queries the user for a virtual environment directory to activate, and pyvenv-workon, which queries for a virtual environment in $WORKON_HOME (from virtualenvwrapper.sh).
#+end_quote

# Per installarlo classicamente, aggiungere questo ad =init.el=:

To install =pyvenv= on vanilla Emacs, add this to =init.el=:

#+begin_src emacs-lisp
(use-package pyvenv
  :ensure t
  :config
  (pyvenv-mode t)
#+end_src

# Io, invece, installerò attraverso la mia literate configuration su Doom Emacs.

I, on the other side, am a Doom Emacs user, so I will add this package to my literate configuration.

# E se volessimo selezionare un interpreter in particolare?
# [[https://blog.fredrikmeyer.net/2020/08/26/emacs-python-venv.html][Fredrik Meyer sul suo blog offre una soluzione]]:

And what if we wanted to select a specific interpreter?
[[https://blog.fredrikmeyer.net/2020/08/26/emacs-python-venv.html][Fredrik Meyer posted about this on his blog:]]

#+begin_src emacs-lisp
;; Set correct Python interpreter
(setq pyvenv-post-activate-hooks
      (list (lambda ()
              (setq python-shell-interpreter (concat pyvenv-virtual-env "bin/python3")))))

(setq pyvenv-post-deactivate-hooks
      (list (lambda ()
              (setq python-shell-interpreter "python3")))))
#+end_src

** Virtualenv for Emacs/Org-mode
# Org-mode aggiunge un ulteriore layer che ci complica un pochino le cose.

Org-mode adds another layer that makes things a little more complicated.

https://emacs.stackexchange.com/questions/24267/using-org-babel-to-enable-virtualenv

We need the full path of our venv:
#+name: full-path-venv
#+begin_src python :var parent_dir=parent-directory-venv() :var new_dir=new-directory-venv()
import os
full_path = os.path.join(os.path.expanduser("~"), parent_dir, new_dir)
return(full_path)
#+end_src

#+RESULTS: full-path-venv
: /home/cromo/.venvs/cv-venv

#+name: venv-activate
#+BEGIN_SRC elisp :session cv-venv :results silent :var path=full-path-venv()
;; doesn't return any value or output, so I'm silencing this block
(pyvenv-activate path)
#+END_SRC

# Verifichiamo che sia stato attivato (result is silenced, look at the minibuffer).

Let's verify that the venv was activated (result is silenced, look at the minibuffer).

#+name: echo-venv
#+BEGIN_SRC sh :session cv-venv :results silent
echo $VIRTUAL_ENV
which python
#+END_SRC

#+name: printing-python-sys-path
#+BEGIN_SRC python :results silent :session cv-venv
import sys
print('\n'.join(sys.path))
#+END_SRC

** Try import
# Vediamo se l'importazione dei nuovi pacchetti è riuscita:

Well, now let's see if the package importing is gone as expected:

#+name: trying-importing-python-libs
#+begin_src python :results output :session cv-venv
try:
    import jinja2
    import babel
    import json
    print("succeded")
except Exception as e:
    print(e)
#+end_src

# Bene, ora possiamo procedere.
Cool, now we can go ahead.

* Jinja environment
# [[https://jinja.palletsprojects.com/en/3.1.x/api/#basics][Dalla documentazione di Jinja2]]:
[[https://jinja.palletsprojects.com/en/3.1.x/api/#basics][From Jinja2 docs]]:

#+begin_quote
This will create a template environment with a loader that looks up templates in the templates folder inside the yourapp Python package (or next to the yourapp.py Python module). It also enables autoescaping for HTML files. This loader only requires that yourapp is importable, it figures out the absolute path to the folder for you.
#+end_quote

#+name: create-jinja-env
#+begin_src python :session cv-venv :results output
try:
    import jinja2
    env = jinja2.Environment()
    env.trim_blocks = True
    env.lstrim_blocks = True
    print("jinja env ready")
except Exception as e:
    print(e)
#+end_src

#+RESULTS: create-jinja-env
: jinja env ready

#+begin_quote
To load a template from this environment, call the get_template() method, which returns the loaded Template.
#+end_quote

#+begin_src python
template = env.get_template("mytemplate.html")
#+end_src

#+RESULTS:

# Non ho bisogno di scrivere necessariamente i template in file a parte.
I don't have the absolute need to write templates in external files.
# [[https://jinja.palletsprojects.com/en/3.1.x/api/#jinja2.Template][Potrei utilizzare il constructor di Jinja2]].

[[https://jinja.palletsprojects.com/en/3.1.x/api/#jinja2.Template][I could use the Jinja2 constructor]].

#+begin_quote
To render it with some variables, call the render() method.
#+end_quote

#+begin_src python
print(template.render(the="variables", go="here"))
#+end_src

#+begin_quote
Using a template loader rather than passing strings to Template or Environment.from_string() has multiple advantages. Besides being a lot easier to use it also enables template inheritance.
#+end_quote

If needed, I could tangle the templates from here and making use of inheritance without giving up to the monolithical literate file.

* Data
** Personal Info
# Usiamo "context" come nome per il nostro dizionario ([[https://realpython.com/primer-on-jinja-templating/][è una convenzione]]):

#+begin_comment
Note: Using context as a name for the collection that stores the variables for a template is a convention. That said, you can name the dictionary differently if you prefer.
#+end_comment

# Intendiamo ottenere un dizionario di questo genere:

We want something like this, a Python dictionary:

#+begin_src python :session cv-venv
basics = {
    "name": "Giovanni Crisalfi",
    "photo": "propic-ciliegio.jpg",
    # ...
    "driving": "Patente B",
}
#+end_src

# Potremmo scrivere i dati direttamente nel dizionario e far comunicare i blocchi, ma poi dipenderemmo dall'esecuzione del codice in sequenza per passare i dati da un blocco all'altro.

We could write directly the data in the dict and make all blocks communicate together, but then we would depend from executing everything in sequence just to maintain the variables all in the same place.

# È più comodo passare i dati attraverso le variabili org-babel, quindi generare i dati a partire da una tabella in org-mode. Inoltre, è anche più facile da manipolare.
# Possiamo inserire le stringhe tra virgolette o senza, non fa differenza.

It's more flexible passing the data through the org-babel variables. This way, we can obtain the data from org tables too.


#+begin_comment
ATTENZIONE!

La tabella qui sotto è quella che va modificata. Il dizionario poco sopra è solo a titolo d'esempio.
#+end_comment

We will got the data for the CV's header from this particular table.

#+name: personalinfo-table
| "name"     | "Giovanni Crisalfi"                |
| "photo"    | "propic-ciliegio.jpg"              |
| "tagline"  | "Studente"                         |
| "homepage" | "www.zwitterio.it"                 |
| "email"    | "giovanni.crisalfi@protonmail.com" |
| "phone"    | "+39 3331604917"                   |
| "location" | "Caltagirone, CT"                  |
| "github"   | "gicrisf"                          |
| "twitter"  | "gicrisf"                          |
| "dob"      | "27 Dicembre 1995"                 |
| "driving"  | "Patente B"                        |

# La tabella mi produce una lista di righe. Per ogni riga troviamo una lista degli elementi nella colonna indicata. Possiamo convertirla in dizionario python in una seconda fase, così:
The table returns a list of rows. For every row we have a list of elements in a specific column. We can convert this 2D array in a python dictionary later, like this:

#+begin_src python :results output :var table=personalinfo-table
# Convert to dictionary
basics = {}
for elem in table:
    basics[elem[0]] = elem[1]

print(basics)
#+end_src

#+RESULTS:
: {'name': 'Giovanni Crisalfi', 'photo': 'propic-ciliegio.jpg', 'tagline': 'Studente', 'homepage': 'www.zwitterio.it', 'email': 'giovanni.crisalfi@protonmail.com', 'phone': '+39 3331604917', 'location': 'Caltagirone, CT', 'github': 'gicrisf', 'twitter': 'gicrisf', 'dob': '27 Dicembre 1995', 'driving': 'Patente B'}

The problem comes when the data are less prone to be structured in a table. Look at the projects, for example, or the work experiences.
# Il problema di questa soluzione è che non si adatta alle fasi successive, in cui le relazioni sono meno tabulabili, per esempio quando tocca occuparsi dei progetti, le esperienze lavorative.

# E allora la cosa più ragionevole sembra quella di scrivere:
So, the best thing to do now could be write data as:
- JSON/Python dict
- Alist/Plist (emacs-lisp)

Yeah, those are flexible without any doubt.
# Cioè delle strutture più flessibili.

I know, I know, lisp can look like a spooky bracket maelstrom to some people, while Python is broadly used, easy to read and kinda looks like a JSON block.
So I would say the more accessible thing to do now is to keep working in Python (with the dictionaries) and passing the data from a block to another as JSON strings.
# Credo che la cosa più conveniente sia continuare a lavorare in Python, quindi coi python dictionaries, ma passando i dati da un blocco all'altro come stringhe JSON.
This way, we avoid to make messes during transfers and we create a system the could potentially be transferred outside org-mode, even if I don't have idea of the reasons that could bring a person to a similar decision. What's up? Are pointing a gun against you to ditch Emacs?
Whatever, with Python we can keep the mainstream idiom, so let's go with it.

# In questo modo evitiamo di fare casini durante i trasferimenti, creiamo un sistema che potrebbe potenzialmente essere gestito fuori da org-mode (come [[https://jsonresume.org/][JSON resume]]) ed evitiamo pure di scrivere lisp. Vorrei che questo testo sia comprensibile a quante più persone possibili e so bene che lisp tende ad intimidire qualcuno. Teniamoci sul mainstream, insomma.

# Cominciamo con l'aggiungere i dati personali dalla tabella qui sopra.

Let's start adding up data from the table up here.

#+name: personalinfo-json
#+begin_src python :sessions cv-venv :results output :var basics_table=personalinfo-table
import json
basics = {}
for elem in basics_table:
    basics[elem[0]] = elem[1]

print(json.dumps(basics))
#+end_src

#+RESULTS: personalinfo-json
: {"name": "Giovanni Crisalfi", "photo": "propic-ciliegio.jpg", "tagline": "Studente", "homepage": "www.zwitterio.it", "email": "giovanni.crisalfi@protonmail.com", "phone": "+39 3331604917", "location": "Caltagirone, CT", "github": "gicrisf", "twitter": "gicrisf", "dob": "27 Dicembre 1995", "driving": "Patente B"}

# Il problema di questo metodo è che rende l'assemblaggio del JSON un po' noioso ed inutilmente sequenziale. Sarebbe assai più comodo se organizzassimo un dizionario python senza passare da JSON e poi facessimo un dump finale in caso di necessità.
# La migliore strategia che mi viene in mente per lavorare in python e ridurre questa intricata filatura di stringhe (e sempre evitando l'esecuzione di un blocco unico sul modello dei Jupyter Notebooks) è fare uso della sintassi noweb ed integrare nello stesso blocco sia il dato che la funzione che lo esporta.

# Cosa ce ne facciamo di questo risultato?
What should we do of this result?

# Aspettiamo di arrivare alla fine ed integriamo tutti i dizionari in un unico dizionario onnicomprensivo che faccia poi da contesto per la generazione in Jinja2.
That's what's gonna happen: we're about to convert every table or python dictionary in a JSON string, then assigning it to a variable which will be parsed and loaded as dictionary in other blocks.
Acting this way, every block will be independent, the data complex will be modular and we don't have to run every block for verifiyng the results from a single edit, but we will just check the single block of interest.
# L'importazione avverrà così, convertendo ogni JSON parziale in un dizionario python che sarà assegnato a una variabile, la quale potrà facilmente essere inclusa in un altro dizionario.
# In questo modo, ogni cambiamento sarà modulare e non richiederà l'intervento su tutti i blocchi di volta in volta.

#+begin_src python :results output :noweb no-export eval
import json
basics = json.loads(
    """
    <<personalinfo-json()>>
    """
)

print(imported)
#+end_src

#+RESULTS:
: {'name': 'Giovanni Crisalfi', 'photo': 'propic-ciliegio.jpg', 'tagline': 'Studente', 'homepage': 'www.zwitterio.it', 'email': 'giovanni.crisalfi@protonmail.com', 'phone': '+39 3331604917', 'location': 'Caltagirone, CT', 'github': 'gicrisf', 'twitter': 'gicrisf', 'dob': '27 Dicembre 1995', 'driving': 'Patente B'}

# Questo metodo consente anche di importare delle semplici stringhe con maggiore facilità, come vedremo coi "personal statement".
# Purtroppo, c'è un limite alla memoria in stack che possiamo pretendere noweb usi per conservare le stringhe generate, quindi in base alla situazione potremmo ottenere questo errore:

Let's keep in mind that there's a limit to the stack memory we can expect noweb can use to manage the string generation, so, depending on the situation, we could get this error:

#+begin_quote
rx--translate-**: Lisp nesting exceeds ‘max-lisp-eval-depth’
#+end_quote

# Bisogna evitare un nesting eccessivo, ma questo torna utile anche per mantenere il codice pulito.

However, this can be seen as an useful sign, because it's always better to avoid an excessive nesting, so that's a good alert sign that remember us to clean the code and keep it simple.

** Personal Statements
*** IT
#+name: personal-statement-it
#+begin_src org :results output
Studente di CTF appassionato di spettroscopia e simulazioni computazionali.
Sostenitore dell'Open Source, vivo su Linux e scrivo sia codice che prosa su Emacs.
Mi interesso di epistemologia, cinema, fumetti e altre lettere.
#+end_src

*** EN
#+name: personal-statement-en
#+begin_src org :results output
Medicinal chemistry student at Unibo • Into spectroscopy and radicals • Linux citizen • Coding in Rust • Scripting in Python/Lisp • Reading and writing around.
#+end_src

** Projects
# In questo blocco è possibile inserire o rimuovere i progetti che vogliamo mostrare nell'esportato.
Here we can insert or remove the project that we want to show in the exported CV.

#+name: projects-json
#+begin_src python :session cv-venv :results output :noweb no-export eval :var esrafel=esrafel-project() :var zhuia=zhuia-project() :var gotosi=gotosi-project() :var unsplash=unsplash-project :var zerm=zerm-project() :var orgcv=orgcv-project() :var target=cv-target
general = [
    esrafel,
    zhuia,
#    gotosi,
    unsplash
]

web = [
    zhuia,
    zerm,
    orgcv,
]

projects = {
    "general": general,
    "web": web
}

projects = [json.loads(x) for x in projects[target]]

print(json.dumps(projects))
#+end_src

#+RESULTS: projects-json
: [{"name": "Esrafel", "description": "Software for least-squares fitting of ESR/EPR spectra with Monte Carlo methods", "when": "Marzo 2020 - Marzo 2022", "link": {"icon": "Github", "text": "gicrisf/esrafel", "href": "https://github.com/gicrisf/esrafel"}, "tags": ["Desktop dev.", "Rust", "GTK", "Spettroscopia"]}, {"name": "Zhuia", "description": "An elegant but still playful theme for Zola", "when": "Feb. 2022 - Marzo 2022", "link": {"icon": "Github", "text": "gicrisf/zhuia", "href": "https://github.com/gicrisf/zhuia"}, "tags": ["Web dev.", "Rust", "Zola", "Tera", "Liquid", "Jinja2"]}, {"name": "3D renders", "description": "Bio/Chem molecular renders for fun and blogging", "when": "", "link": {"icon": "Unsplash", "text": "@gicrisf", "href": "https://unsplash.com/@gicrisf"}, "tags": ["Grafica", "Chimica", "GIMP", "VMD"]}]

*** Esrafel
#+name: esrafel-project
#+begin_src python :session cv-venv :results output
esrafel = {
    "name": "Esrafel",
    "description": "Software for least-squares fitting of ESR/EPR spectra with Monte Carlo methods",
    "when": "Marzo 2020 - Marzo 2022",
    "link": {
        "icon": "Github",
        "text": "gicrisf/esrafel",
        "href": "https://github.com/gicrisf/esrafel"
    },
    "tags": ["Desktop dev.", "Rust", "GTK", "Spettroscopia"]
}

print(json.dumps(esrafel))
#+end_src

#+RESULTS: esrafel-project
: {"name": "Esrafel", "description": "Software for least-squares fitting of ESR/EPR spectra with Monte Carlo methods", "when": "Marzo 2020 - Marzo 2022", "link": {"icon": "Github", "text": "gicrisf/esrafel", "href": "https://github.com/gicrisf/esrafel"}, "tags": ["Desktop dev.", "Rust", "GTK", "Spettroscopia"]}

**** TODO Decorator
# Per non scrivere sempre =print(json.dumps(X))=, potrei scrivere un decoratore.
To avoid writing =print(json.dumps(X))= everytime, I could write a decorator.
Before doing this, I was thinking about making a =utils.py= module to tangle from this file and importing it with the main libraries like json, jinja2 and Babel.

*** Zhuia
#+name: zhuia-project
#+begin_src python :session cv-venv :results output
zhuia = {
    "name": "Zhuia",
    "description": "An elegant but still playful theme for Zola",
    "when": "Feb. 2022 - Marzo 2022",
    "link": {
        "icon": "Github",
        "text": "gicrisf/zhuia",
        "href": "https://github.com/gicrisf/zhuia"
    },
    "tags": ["Web dev.", "Rust", "Zola", "Tera", "Liquid", "Jinja2"]
}

print(json.dumps(zhuia))
#+end_src

#+RESULTS: zhuia-project
: {"name": "Zhuia", "description": "An elegant but still playful theme for Zola", "when": "Feb. 2022 - Marzo 2022", "link": {"icon": "Github", "text": "gicrisf/zhuia", "href": "https://github.com/gicrisf/zhuia"}, "tags": ["Web dev.", "Rust", "Zola", "Tera", "Liquid", "Jinja2"]}

*** Gotosi
#+name: gotosi-project
#+begin_src python :session cv-venv :results output
gotosi = {
    "name": "Gotosi",
    "description": "Isotope oriented periodic table of elements",
    "when": "Feb. 2021 - Maggio 2021",
    "link": {
        "icon": "Github",
        "text": "gicrisf/gotosi",
        "href": "https://github.com/gicrisf/gotosi"
    },
    "tags": ["Desktop dev.", "Vala", "C", "GTK", "Chemistry"]
}

print(json.dumps(gotosi))
#+end_src

#+RESULTS: gotosi-project
: {"name": "Gotosi", "description": "Isotope oriented periodic table of elements", "when": "Feb. 2021 - Maggio 2021", "link": {"icon": "Github", "text": "gicrisf/gotosi", "href": "https://github.com/gicrisf/gotosi"}, "tags": ["Desktop dev.", "Vala", "C", "GTK", "Chemistry"]}

*** Unsplash
#+name: unsplash-project
#+begin_src python :session cv-venv :results output
unsplash = {
    "name": "3D renders",
    "description": "Bio/Chem molecular renders for fun and blogging",
    "when": "",
    "link": {
        "icon": "Unsplash",
        "text": "@gicrisf",
        "href": "https://unsplash.com/@gicrisf"
    },
    "tags": ["Grafica", "Chimica", "GIMP", "VMD"]
}

print(json.dumps(unsplash))
#+end_src

#+RESULTS: unsplash-project
: {"name": "3D renders", "description": "Bio/Chem molecular renders for fun and blogging", "when": "", "link": {"icon": "Unsplash", "text": "@gicrisf", "href": "https://unsplash.com/@gicrisf"}, "tags": ["Grafica", "Chimica", "GIMP", "VMD"]}

*** Zerm
#+name: zerm-project
#+begin_src python :session cv-venv :results output
z = {
    "name": "Zerm",
    "description": "My fork of a minimalist and dark theme for Zola",
    "when": "Giugno 2021 - In corso",
    "link": {
        "icon": "Github",
        "text": "gicrisf/zerm",
        "href": "https://github.com/gicrisf/zerm"
    },
    "tags": ["Web dev.", "Rust", "Zola", "Tera", "Liquid", "Jinja2"]
}

print(json.dumps(z))
#+end_src

*** Org CV
#+name: orgcv-project
#+begin_src python :session cv-venv :results output
z = {
    "name": "Org CV",
    "description": "My Curriculum Vitae, written in Org-mode and powered by LaTeX + Python/Jinja2.",
    "when": "Agosto 2022",
    "link": {
        "icon": "Github",
        "text": "gicrisf/orgcv",
        "href": "https://github.com/gicrisf/orgcv"
    },
    "tags": ["Emacs", "Org Mode", "Python", "Jinja2", "Liquid"]
}

print(json.dumps(z))
#+end_src

** Seminars
#+name: seminars-json
#+begin_src python :session cv-venv :results output :noweb no-export eval :var festival_scienza_medica=festival-scienza-medica-event() :var sitox=sitox-event :var chemistry_world_driving=chemistry-world-driving-event() :var chemistry_world_accelerating=chemistry-world-accelerating-event() :var drug_targeting=drug-targeting() :var molecular_machines=molecular-machines-days() :var da_scienziati_a_comunicatori=da-scienziati-a-comunicatori()
s = [
    festival_scienza_medica,
    sitox,
    chemistry_world_driving,
    chemistry_world_accelerating,
    # da_scienziati_a_comunicatori,
    # molecular_machines,
    # drug_targeting,
]

s = [json.loads(x) for x in s]
print(json.dumps(s))
#+end_src

#+RESULTS: seminars-json
: [{"name": "Festival della Scienza Medica", "where": "Palazzo Re Enzo - piazza Nettuno 1 - Bologna", "when": "Anni: 2016 - 2017 - 2018 - 2019"}, {"name": "18\u00b0 Congresso Nazionale Sitox", "where": "Savoia Hotel Regency - Via del Pilastro 2 - 40127 Bologna", "when": "10 Apr. 2018 - 13 Apr. 2018"}, {"name": "Driving the development of bio-based polymers with molecular simulation", "where": "Chemistry World Webinar", "when": "13 Apr. 2022"}, {"name": "Accelerating first-in-class and best-in-class programs using a large-scale digital chemistry strategy", "where": "Chemistry World Webinar", "when": "24 Maggio 2022"}]

*** Template
#+begin_src python :session cv-venv :results output
t = {
    "name": "",
    "where": "",
    "when": "",
}

print(json.dumps(t))
#+end_src

*** Festival della scienza medica
#+name: festival-scienza-medica-event
#+begin_src python :session cv-venv :results output
festival_scienza_medica = {
    "name": "Festival della Scienza Medica",
    "where": "Palazzo Re Enzo - piazza Nettuno 1 - Bologna",
    "when": "Anni: 2016 - 2017 - 2018 - 2019"
}

print(json.dumps(festival_scienza_medica))
#+end_src

#+RESULTS: festival-scienza-medica-event
: {"name": "Festival della Scienza Medica", "where": "Palazzo Re Enzo - piazza Nettuno 1 - Bologna", "when": "Anni: 2016 - 2017 - 2018 - 2019"}

*** SITOX
#+name: sitox-event
#+begin_src python :session cv-venv :results output
sitox = {
    "name": "18° Congresso Nazionale Sitox",
    "where": "Savoia Hotel Regency - Via del Pilastro 2 - 40127 Bologna",
    "when": "10 Apr. 2018 - 13 Apr. 2018",
}

print(json.dumps(sitox))
#+end_src

#+RESULTS: sitox-event
: {"name": "18\u00b0 Congresso Nazionale Sitox", "where": "Savoia Hotel Regency - Via del Pilastro 2 - 40127 Bologna", "when": "10 Apr. 2018 - 13 Apr. 2018"}

*** Chemistry World
#+name: chemistry-world-driving-event
#+begin_src python :session cv-venv :results output
chemistry_world_driving = {
    "name": "Driving the development of bio-based polymers with molecular simulation",
    "where": "Chemistry World Webinar",
    "when": "13 Apr. 2022",
}

print(json.dumps(chemistry_world_driving))
#+end_src

#+RESULTS: chemistry-world-driving-event
: {"name": "Driving the development of bio-based polymers with molecular simulation", "where": "Chemistry World Webinar", "when": "13 Apr. 2022"}

#+name: chemistry-world-accelerating-event
#+begin_src python :session cv-venv :results output
chemistry_world_accelerating = {
    "name": "Accelerating first-in-class and best-in-class programs using a large-scale digital chemistry strategy",
    "where": "Chemistry World Webinar",
    "when": "24 Maggio 2022",
}

print(json.dumps(chemistry_world_accelerating))
#+end_src

#+RESULTS: chemistry-world-accelerating-event
: {"name": "Accelerating first-in-class and best-in-class programs using a large-scale digital chemistry strategy", "where": "Chemistry World Webinar", "when": "24 Maggio 2022"}

*** Seminari comunicazione
#+name: da-scienziati-a-comunicatori
#+begin_src python :session cv-venv :results output
scicomm = {
    "name": "Da scienziati a comunicatori scientifici: il ruolo di comunicazione della scienza nel rapporto tra scienza e società",
    "where": "Via Irnerio 48, Bologna - Aula B di Anatomia",
    "when": "3 Mar. 2017 - 28 Apr. 2017",
}

print(json.dumps(scicomm))
#+end_src

#+RESULTS: da-scienziati-a-comunicatori
: {"name": "Da scienziati a comunicatori scientifici: il ruolo di comunicazione della scienza nel rapporto tra scienza e societ\u00e0", "where": "Via Irnerio 48, Bologna - Aula B di Anatomia", "when": "3 Mar. 2017 - 28 Apr. 2017"}

*** Drug targeting
#+name: drug-targeting
#+begin_src python :session cv-venv :results output
t = {
    "name": "Drug targeting: getting your compounds to cross the Rubicon",
    "where": "Via Belmeloro 6, Bologna",
    "when": "4 Sett. 2017",
}

print(json.dumps(t))
#+end_src

#+RESULTS: drug-targeting
: {"name": "Drug targeting: getting your compounds to cross the Rubicon", "where": "Via Belmeloro 6, Bologna", "when": "4 Sett. 2017"}

*** Molecular Machines Days
#+name: molecular-machines-days
#+begin_src python :session cv-venv :results output
t = {
    "name": "Molecular Machines Days",
    "where": "Dipartimento di Chimica Giacomo Ciamician, Aula I",
    "when": "21 Nov. 2018",
}

print(json.dumps(t))
#+end_src

#+RESULTS: molecular-machines-days
: {"name": "Molecular Machines Days", "where": "Dipartimento di Chimica Giacomo Ciamician, Aula I", "when": "21 Nov. 2018"}

** Skills
# Questo è uno di quei casi in cui andrebbe anche bene raccogliere i dati come =value= anziché come output, riducendo così la quantità di JSON chunks che fanno avanti e indietro.
# Potrei farlo per mezzo di una tabella, ma il problema della tabella è la scarsa flessibilità. E se domani volessi associare dei valori di autovalutazione per ogni tag?
# Per ridurre il boilerplate (e considerata la semplicità disarmante del codice), ho deciso di raccogliere tutto in un unico blocco.

Here I could easily take the data from a table and loading them in the block as =value= (not =output=). This way, I would massively reduce the number of JSON chunks delivered between the blocks.
But what if I want to extend the logic of the template associating an autovalutation parameter to the tag?
There's a simple way to solve this problem and highly reduce the boilerplate. Just write everything in the block below.

#+name: skills-json
#+begin_src python :session cv-venv :results output
# GENERAL
general = ["Pharmaceutical chemistry", "Spectroscopy",
           "Programming", "Web dev.", "Desktop dev.",
           "Data viz."]

# WEB DEV.
web = ["HTML5", "CSS/SCSS", "JS/TS",
       "Liquid", "Jinja2", "Tera",
       "Flask", "Django", "Pelican",
       "Rust", "PHP", "Wordpress",
       "Grav", "Twig", "Zola", "Elm"]

# CTF/Pharmaceutical Chemistry
pharma = ["Pharmaceutical Analysis", "Organic Chemistry",
          "EPR/NMR Spectroscopy", "Stereochemistry",
          "Data viz."]

# Desktop/Backend
desktop = ["Rust", "Python", "Lisp", "Vala", "C", "Git", "PHP",
           "GTK", "Numpy", "Matplotlib", "LaTeX", "Bash"]

# Graphics
graphics = ["GIMP", "Inkscape", "VMD"]

# Build the dictionary
skills = {
    "name": "Skills",
    "categories": {
        "general": general,
        "web": web,
        "pharma": pharma,
        "desktop": desktop,
        "graphics": graphics,
    }
}

# Print out the JSON
print(json.dumps(skills))
#+end_src

#+RESULTS: skills-json
: {"name": "Skills", "categories": {"general": ["Pharmaceutical chemistry", "Spectroscopy", "Programming", "Web dev.", "Desktop dev.", "Data viz."], "web": ["HTML5", "CSS/SCSS", "JS/TS", "Liquid", "Jinja2", "Tera", "Flask", "Django", "Pelican", "Rust", "PHP", "Wordpress", "Grav", "Twig", "Zola", "Elm"], "pharma": ["Pharmaceutical Analysis", "Organic Chemistry", "EPR/NMR Spectroscopy", "Stereochemistry", "Data viz."], "desktop": ["Rust", "Python", "Lisp", "Vala", "C", "Git", "PHP"], "graphics": ["GIMP", "Inkscape"]}}

** Experiences
#+name: exps-json
#+begin_src python :session cv-venv :results output :noweb no-export eval :var tirocinio=farmacia-ospedaliera-exp() :var tesi=tesi-sperimentale-exp()
exps = [
    tirocinio,
    tesi,
]

exps = [json.loads(x) for x in exps]

print(json.dumps(exps))
#+end_src

#+RESULTS: exps-json
: [{"name": "Tirocinio in Farmacia Ospedaliera", "where": "Ospedale Gravina di Caltagirone", "when": "Ottobre 2020 - Luglio 2021"}, {"name": "Tirocinio per tesi sperimentale", "where": "Dipartimento di \"Chimica Giacomo Ciamician\" - Unibo", "when": "Ottobre 2019 - Maggio 2020"}]

*** Farmacia ospedaliera
#+name: farmacia-ospedaliera-exp
#+begin_src python :session cv-venv :results output
farmacia_ospedaliera = {
    "name": "Tirocinio in Farmacia Ospedaliera",
    "where": "Ospedale Gravina di Caltagirone",
    "when": "Ottobre 2020 - Luglio 2021",
}

print(json.dumps(farmacia_ospedaliera))
#+end_src

*** Tesi sperimentale
#+name: tesi-sperimentale-exp
#+begin_src python :session cv-venv :results output
tesi_sperimentale = {
    "name": "Tirocinio per tesi sperimentale",
    "where": "Dipartimento di \"Chimica Giacomo Ciamician\" - Unibo",
    "when": "Ottobre 2019 - Maggio 2020",
}

print(json.dumps(tesi_sperimentale))
#+end_src

#+RESULTS: tesi-sperimentale-exp
: {"name": "Tirocinio per tesi sperimentale", "where": "Dipartimento di \"Chimica Giacomo Ciamician\" - Unibo", "when": "Ottobre 2019 - Maggio 2020"}

** Education

#+name: edu-json
#+begin_src python :session cv-venv :results output :noweb no-export eval :var diploma=diploma-scientifico-edu() :var ctf=ctf-edu() :var adme=adme-edu()
edu_list = [
    diploma,
    ctf,
    adme,
]

edu = [json.loads(x) for x in edu_list]

print(json.dumps(edu))
#+end_src

#+RESULTS: edu-json
: [{"name": "Diploma Liceo Scientifico", "where": "Liceo Scientifico E. Majorana - Caltagirone", "when": "Sett. 2009 - Giugno 2014"}, {"name": "Magistrale a ciclo unico in Chimica e Tecnologia Farmaceutiche", "where": "Dipartimento di Farmacia e Biotecnologie FABIT - Universit\u00e0 di Bologna", "when": "Sett. 2014 - In corso"}, {"name": "Summer School in Pharmaceutical Analysis", "where": "Campus di Rimini - Palazzo Ruffi-Briolini", "when": "18 Sett. 2017 - 20 Sett. 2017", "comment": "Advanced Analytical Methodologies for Adsorption, Distribution, Metabolism, Excretion and Toxicity (ADMET) Studies"}]

*** Diploma Scientifico
#+name: diploma-scientifico-edu
#+begin_src python :session cv-venv :results output
diploma_scientifico = {
    "name": "Diploma Liceo Scientifico",
    "where": "Liceo Scientifico E. Majorana - Caltagirone",
    "when": "Sett. 2009 - Giugno 2014",
}

print(json.dumps(diploma_scientifico))
#+end_src

#+RESULTS: diploma-scientifico-edu
: {"name": "Diploma Liceo Scientifico", "where": "Liceo Scientifico E. Majorana - Caltagirone", "when": "Sett. 2009 - Giugno 2014"}

*** CTF
#+name: ctf-edu
#+begin_src python :session cv-venv :results output
ctf = {
    "name": "Magistrale a ciclo unico in Chimica e Tecnologia Farmaceutiche",
    "where": "Dipartimento di Farmacia e Biotecnologie FABIT - Università di Bologna",
    "when": "Sett. 2014 - In corso",
}

print(json.dumps(ctf))
#+end_src

#+RESULTS: ctf-edu
: {"name": "Magistrale a ciclo unico in Chimica e Tecnologia Farmaceutiche", "where": "Dipartimento di Farmacia e Biotecnologie FABIT - Universit\u00e0 di Bologna", "when": "Sett. 2014 - In corso"}

*** Summer School in Pharma Analysis
#+name: adme-edu
#+begin_src python :session cv-venv :results output
pharma_analysis_summer_school = {
    "name": "Summer School in Pharmaceutical Analysis",
    "where": "Campus di Rimini - Palazzo Ruffi-Briolini",
    "when": "18 Sett. 2017 - 20 Sett. 2017",
    "comment": "Advanced Analytical Methodologies for Adsorption, Distribution, Metabolism, Excretion and Toxicity (ADMET) Studies"
}

print(json.dumps(pharma_analysis_summer_school))
#+end_src

#+RESULTS: adme-edu
: {"name": "Summer School in Pharmaceutical Analysis", "where": "Campus di Rimini - Palazzo Ruffi-Briolini", "when": "18 Sett. 2017 - 20 Sett. 2017", "comment": "Advanced Analytical Methodologies for Adsorption, Distribution, Metabolism, Excretion and Toxicity (ADMET) Studies"}

*** TODO 24 CFU
*** TODO ONSCI
Officina di narrazione della Scienza.
7-14 settembre a Bologna.
Dipartimento di Fisica e Astronomia Unibo.
Tempi e luoghi per pensare con la scienza: nuovi linguaggi per l'educazione STEM.

** Langs
#+name: langs-json
#+begin_src python :session cv-venv :results output
langs = [{"name": "Italiano", "level": "5" },
         {"name": "Inglese", "level": "4"},
         {"name": "Francese", "level": "1"}]

print(json.dumps(langs))
#+end_src

#+RESULTS: langs-json
: [{"name": "italiano", "level": 5}, {"name": "Inglese", "level": 4}, {"name": "Francese", "level": 1}]

* LaTeX
# L'idea è di esportare tutto con org-exporter per LaTeX, wrappando in blocchi org-mode che a loro volta wrappino del LaTeX puro. Così facendo, possiamo sfruttare esportare direttamente da questo documento, senza avviare =pdflatex= da terminale e anche impiegare le impostazioni interne di org-latex.

#+begin_comment
emacs-lisp
(setq org-latex-logfiles-extensions (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl" "xmpi" "run.xml" "bcf")))
#+end_comment

# Per fare prima, aggiungo direttamente questa variabile alla configurazione generale di Emacs.

# Il LaTeX finale (come tutti i LaTeX) sarà costituito da una testa (=head=) e un documento (=document=):

Select here what kind of document you want to target:
- General (as =general=)
- Pharma (as =pharma=, TODO)
- Web (as =web=)

#+name: cv-target
#+begin_src python
target="general"

return(target)
#+end_src

#+RESULTS: cv-target
: web

The final LaTeX file (as every LaTeX file) will be made with two consequential parts: the =head= and the =document= (which is the body, the section with the actual text).

This block tangles the general version:

# :tangle cv.tex
#+begin_src latex :noweb no-export :tangle cv-general-unstable.tex
<<head-latex>>

<<document-general-latex>>
#+end_src

This block tangles the web version:

# :tangle cv-web-unstable.tex
#+begin_src latex :noweb no-export
<<head-latex>>

<<document-web-latex>>
#+end_src

Just comment out the =:tangle= command to disable an export and speed up your compilation times!

** Dependencies
In order to render the CV in LaTeX, I use the AltaCV template.
# Per scrivere il CV in LaTeX utilizzo il template AltaCV.

As the README say, those are the minimal requirment for the compilation:
# Citando il README, questi sono i requisiti per la compilazione:

#+begin_quote
- pdflatex + biber + pdflatex
- AltaCV uses fontawesome5.
#+end_quote

# Prima di tentare la conversione in pdf (es. con =pdflatex=) ricorda che sono necessarie le seguenti dipendenze.
Before you try to convert in pdf (e.g. with =pdflatex=), remember to check on those dependencies.

*** Fonts
# In effetti, su AUR si trova =texlive-fonts-fontawesome=...
On AUR you can find =texlive-fonts-fontawesome=...

#+begin_src bash
yay texlive-fonts-fontawesome
#+end_src

# ... ma visto che ci serve anche Roboto (o un font alternativo a nostra scelta), facciamo prima ad installare il pacchetto coi font:
... but, considering that you're going to need Roboto, Lato or other fonts to your choice, it's better to install the font package:

#+begin_src bash
sudo pacman -S texlive-fontsextra
#+end_src

# Viceversa, potremmo sfruttare i font di sistema compilando con XeLaTeX o LuaLaTex:
In alternative, you could use the system fonts by compiling with XeLaTeX or LuaLaTeX:

#+begin_quote
- Can now be compiled with pdflatex, XeLaTeX and LuaLaTeX!
- Note that to compile with XeLaTeX, you should use a command line as follows, per the pdfx documentation: xelatex -shell-escape -output-driver="xdvipdfmx -z 0" sample.tex
#+end_quote

*** Bibtex
#+begin_src bash
sudo pacman -S texlive-bibtexextra
#+end_src

** Head
*** Overview
#+name: head-latex
#+begin_src latex :noweb no-export
% Created 2022-07-27 mer 04:05
% Intended LaTeX compiler: pdflatex

<<class-latex>>

<<layout-latex>>

<<fonts-latex>>

<<colors-latex>>

<<bullets-latex>>

<<font-packages-latex>>

<<columns-latex>>

<<footnotes-latex>>

<<bib-latex>>

<<exporter-latex>>
#+end_src

*** Class
=withyper= serve ad AltaCV per rendere cliccabili i link nelle "personal info":

#+begin_quote
As of v1.3 the =withhyper= document class option will make the "personal info" fields into clickable hyperlinks (where it makes sense). See below for more details.
#+end_quote

#+name: class-latex
#+begin_src latex
\documentclass[10pt,a4paper,ragged2e,withhyper]{altacv}
#+end_src

*** Layout
#+name: layout-latex
#+begin_src latex
% Change the page layout if you need to
\geometry{left=1.25cm,right=1.25cm,top=1.5cm,bottom=1.5cm,columnsep=1.2cm}
#+end_src

*** Fonts
#+begin_quote
Use =\renewcommand= to change these.

- =\namefont=
- =\taglinefont=
- =\personalinfofont=
- =\cvsectionfont=
- =\cvsubsectionfont=
#+end_quote

**** Commands
#+name: fonts-latex
#+begin_src latex
% Use roboto and lato for fonts
\renewcommand{\familydefault}{\sfdefault}

% Change some fonts, if necessary
\renewcommand{\namefont}{\Huge\rmfamily\bfseries}
\renewcommand{\personalinfofont}{\footnotesize}
\renewcommand{\cvsectionfont}{\LARGE\rmfamily\bfseries}
\renewcommand{\cvsubsectionfont}{\large\bfseries}
#+end_src

**** Packages
#+name: font-packages-latex
#+begin_src latex
\usepackage[rm]{roboto}
\usepackage[defaultsans]{lato}
#+end_src

*** Colors
[[https://github.com/liantze/altaCV#configurable-colours][Dal README di AltaCV]]:

#+begin_quote
Use =\colorlet= or =\definecolor= to change these.

- accent
- emphasis
- heading
- headingrule
- subheading
- body
- name
- tagline
#+end_quote

#+name: colors-latex
#+begin_src latex
% Change the colours if you want to
\definecolor{SlateGrey}{HTML}{2E2E2E}
\definecolor{LightGrey}{HTML}{666666}
\definecolor{DarkPastelRed}{HTML}{450808}
\definecolor{PastelRed}{HTML}{8F0D0D}
\definecolor{GoldenEarth}{HTML}{E7D192}

\colorlet{name}{black}
\colorlet{tagline}{PastelRed}
\colorlet{heading}{DarkPastelRed}
\colorlet{headingrule}{GoldenEarth}
\colorlet{subheading}{PastelRed}
\colorlet{accent}{PastelRed}
\colorlet{emphasis}{SlateGrey}
\colorlet{body}{LightGrey}
#+end_src

*** Bullets
#+name: bullets-latex
#+begin_src latex
% Change the bullets for itemize and rating marker
% for cvskill if you want to
\renewcommand{\itemmarker}{{\small\textbullet}}
\renewcommand{\ratingmarker}{\faCircle}
#+end_src

*** Columns
#+begin_quote
This new layout uses the paracol package for typesetting the left and right columns that can break across pages. It also makes changing the column widths easier:
#+end_quote

#+begin_src latex
%% Set the left/right column width ratio to 6:4.
\columnratio{0.6}

% Start a 2-column paracol. Both the left and right columns will automatically
% break across pages if things get too long.
\begin{paracol}{2}
\cvsection{Experience}
...
... END OF LEFT COLUMN CONTENTS ...

% Now switch to the right column.
\switchcolumn
\cvsection{Education}
...
...END OF RIGHT COLUMN CONTENTS ...
\end{paracol}
#+end_src

#+begin_quote
You can also use =\swithcolumn*= for "synchronising" the columns, as well as other commands from the =paracol= package. See the [[http://texdoc.net/pkg/paracol][paracol package documentation]] for further details.
#+end_quote

#+name: columns-latex
#+begin_src latex
\usepackage{paracol}
\columnratio{0.6} % Set the left/right column width ratio to 6:4.
#+end_src

*** Footnotes
#+name: footnotes-latex
#+begin_src latex
\usepackage[bottom]{footmisc}
#+end_src

*** Bibliography
#+name: bib-latex
#+begin_src latex
\DeclareNameAlias{sortname}{given-family}

\addbibresource{sample.bib}

% \usepackage[style=trad-abbrv,sorting=none,sortcites=true,doi=false,url=false,giveninits=true,hyperref]{biblatex}
#+end_src

# Commento via =\usepackage= perché:
I'm commenting out =\usepackage= because:
#+begin_quote
! LaTeX Error: Option clash for package biblatex.
#+end_quote

Probably, AltaCV already loads =biblatex=, so this command can be skipped.
# È probabile che AltaCV già carichi =biblatex= e che questo comando sia ridondante.

*** Exporter
#+name: exporter-latex
#+begin_src latex
\author{Giovanni Crisalfi}
\date{\today}
\title{}
#+end_src

** Document
*** General
#+name: document-general-latex
#+begin_src latex :noweb no-export
\begin{document}

<<personalinfo-latex()>>

\makecvheader

\begin{paracol}{2}

<<personal-statement-latex()>>

\vspace{.1cm}

\cvsection{Progetti}

<<projects-latex()>>

\cvsection{Seminari}

<<seminars-latex()>>

\switchcolumn

\cvsection{Competenze}

<<skills-latex()>>

\cvsection{Esperienze}

<<exps-latex()>>

\cvsection{Istruzione}

<<edu-latex()>>

\cvsection{Lingue}

<<langs-latex()>>

\end{paracol}
\end{document}
#+end_src

*** Web Dev
#+name: document-web-latex
#+begin_src latex :noweb no-export
\begin{document}

<<personalinfo-latex()>>

\makecvheader

\begin{paracol}{2}

<<personal-statement-latex()>>

\vspace{.1cm}

\cvsection{Progetti}

<<projects-latex()>>

% Seminars are chemistry-only
% We can comment them out for a web cv
% \cvsection{Seminari}

% < <seminars-latex()> >

\cvsection{Sviluppo Web}

<<tools-latex()>>

\switchcolumn

\cvsection{Competenze}

<<skills-latex()>>

\cvsection{Esperienze}

<<exps-latex()>>

\cvsection{Istruzione}

<<edu-latex()>>

\cvsection{Lingue}

<<langs-latex()>>

\end{paracol}
\end{document}
#+end_src

*** Header
# Vogliamo ottenere un risultato del genere:
We want to write down something like this:

#+begin_src latex
\name{Giovanni Crisalfi}
\photoR{2.8cm}{propic-ciliegio.jpg}
\tagline{Studente}

\personalinfo{
  % ...
}
#+end_src

# Scriviamo un template:
We write a template:

#+name: personalinfo-jinja-latex
#+begin_src latex :results output
\name{ {{ctx.name}} }
\photoR{2.8cm}{ {{ctx.photo}} }
\tagline{ {{ctx.tagline}} }

\personalinfo{
  \homepage{ {{ctx.homepage}} }
  \email{ {{ctx.email}} }
  \phone{ {{ctx.phone}} }
  \location{ {{ctx.location}} }
  \github{ {{ctx.github}} }
  \twitter{ {{ctx.twitter}} }
  % \linkedin{  }
  \dob{ {{ctx.dob}} }
  \driving{ {{ctx.driving}} }
}
#+end_src

# Intanto verifichiamo che Jinja2 stia funzionando come si deve:
In the meanwhile, let's verify that Jinja2 is working as expected:

#+begin_src python :session cv-venv :results output :var context=personalinfo-table
template = env.from_string("Hello, {{ name }}!")

print(template.render(name="World"))
#+end_src

#+RESULTS:
: Hello, World!

# Ora renderizziamo il primo template:
Now, let's render the first template:

#+name: personalinfo-latex
#+begin_src python :session cv-venv :results output latex :var templ=personalinfo-jinja-latex :var ctx=personalinfo-json()
template = env.from_string(templ)
print(template.render(ctx=json.loads(ctx)))
#+end_src

#+RESULTS: personalinfo-latex
#+begin_export latex
\name{ Giovanni Crisalfi }
\photoR{2.8cm}{ propic-ciliegio.jpg }
\tagline{ Studente }

\personalinfo{
  \homepage{ www.zwitterio.it }
  \email{ giovanni.crisalfi@protonmail.com }
  \phone{ +39 3331604917 }
  \location{ Caltagirone, CT }
  \github{ gicrisf }
  \twitter{ gicrisf }
  % \linkedin{  }
  \dob{ 27 Dicembre 1995 }
  \driving{ Patente B }
}
#+end_export

*** Column 1
**** Personal Statement
#+name: personal-statement-latex
#+begin_src latex :noweb no-export
\begin{quote}
<<personal-statement-it>>
\end{quote}
#+end_src

#+RESULTS: personal-statement-latex
#+begin_export latex
\begin{quote}
Studente di CTF appassionato di spettroscopia e simulazioni computazionali.
Sostenitore dell'Open Source, vivo su Linux e scrivo sia codice che prosa su Emacs.
Mi interesso di epistemologia, cinema, fumetti e altre lettere.
\end{quote}
#+end_export

**** Projects
#+name: projects-jinja-latex
#+begin_src latex :results output
{% for project in projects %}
\cvevent{ {%- if project.name -%}{{project.name}}{%- endif -%} }{ {%- if project.description -%}{{project.description}}{%- endif -%} }{ {%- if project.when -%}{{project.when}}{%- endif -%} }{}

\begin{itemize}
\item \href{ {{project.link.href}} }{\fa{{ project.link.icon }} {{ project.link.text }}}
\end{itemize}
\vspace{.2cm}

{% for tag in project.tags %}
\cvtag{ {{tag}} }
{% endfor %}
{% if not loop.last %}
\par\divider
{% endif %}
{% endfor %}
#+end_src

# Renderizziamo tutti i progetti:
Rendering every project:

#+name: projects-latex
#+begin_src python :session cv-venv :results output latex :var templ=projects-jinja-latex :var ctx=projects-json()
template = env.from_string(templ)
print(template.render(projects=json.loads(ctx)))
#+end_src

#+RESULTS: projects-latex
#+begin_export latex
\cvevent{Esrafel}{Software for least-squares fitting of ESR/EPR spectra with Monte Carlo methods}{Marzo 2020 - Marzo 2022}{}

\begin{itemize}
\item \href{ https://github.com/gicrisf/esrafel }{\faGithub gicrisf/esrafel}
\end{itemize}
\vspace{.2cm}

\cvtag{ Desktop dev. }
\cvtag{ Rust }
\cvtag{ GTK }
\cvtag{ Spettroscopia }
\par\divider
\cvevent{Zhuia}{An elegant but still playful theme for Zola}{Feb. 2022 - Marzo 2022}{}

\begin{itemize}
\item \href{ https://github.com/gicrisf/zhuia }{\faGithub gicrisf/zhuia}
\end{itemize}
\vspace{.2cm}

\cvtag{ Web dev. }
\cvtag{ Rust }
\cvtag{ Zola }
\cvtag{ Tera }
\cvtag{ Liquid }
\cvtag{ Jinja2 }
\par\divider
\cvevent{3D renders}{Bio/Chem molecular renders for fun and blogging}{}{}

\begin{itemize}
\item \href{ https://unsplash.com/@gicrisf }{\faUnsplash @gicrisf}
\end{itemize}
\vspace{.2cm}

\cvtag{ Grafica }
\cvtag{ Chimica }
\cvtag{ GIMP }
\cvtag{ VMD }
#+end_export

**** Seminars
#+name: seminars-jinja-latex
#+begin_src latex
{% for seminario in seminari %}
\cvevent{ {%- if seminario.name -%} {{seminario.name}}{%- endif -%} }{ {%- if seminario.where -%} {{seminario.where}}{%- endif -%} }{ {%- if seminario.when -%} {{seminario.when}}{%- endif -%} }{}

{% if not loop.last %}
\par\divider
{% endif %}
{% endfor %}
#+end_src

# Renderizziamo tutti i progetti:
Let's render every project in the list:

#+name: seminars-latex
#+begin_src python :session cv-venv :results output latex :var templ=seminars-jinja-latex :var ctx=seminars-json()
template = env.from_string(templ)
print(template.render(seminari=json.loads(ctx)))
#+end_src

#+RESULTS: seminari-latex
#+begin_export latex
\cvevent{Festival della Scienza Medica}{Palazzo Re Enzo - piazza Nettuno 1 - Bologna}{Anni: 2016 - 2017 - 2018 - 2019}{}

\par\divider
\cvevent{18° Congresso Nazionale Sitox}{Savoia Hotel Regency - Via del Pilastro 2 - 40127 Bologna}{10 Apr. 2018 - 13 Apr. 2018}{}

\par\divider
\cvevent{Driving the development of bio-based polymers with molecular simulation}{Chemistry World Webinar}{13 Apr. 2022}{}

\par\divider
\cvevent{Accelerating first-in-class and best-in-class programs using a large-scale digital chemistry strategy}{Chemistry World Webinar}{24 Maggio 2022}{}
#+end_export

**** Web tools
#+name: tools-latex
#+begin_src org :session cv-venv :results value latex
In questa versione del mio CV ho omesso progetti o seminari relativi alla chimica o sullo sviluppo di desktop app e mi sono focalizzato sullo sviluppo web.
Ho iniziato ad utilizzare questi strumenti nell'ormai lontano 2017, per sviluppare il mio blog. Da allora, la cosa mi è sfuggita di mano. Come molti, ho cominciato con Wordpress, poi (per vari motivi) mi sono spostato su Django.
Stando a contatto con l'ecosistema web di Python, mi sono innamorato di *Jinja2*, un motore di templating estremamente versatile che oggi vive una seconda vita con una sua reimplementazione in Ruby, cioè *Liquid*. Ho lavorato anche con Grav, in PHP, ed ho spesso messo le mani su framework per SPA in JS/Typescript, come React, Vue, Svelte ed Elm, ma il linguaggio "general purpose" che più mi ha conquistato è Rust, quindi negli ultimi anni ho scritto temi con Zola e Tera (altra reimplementazione di Jinja2, ma in Rust). Più di recente mi sono avvicinato a Yew, un framework che parte dalle intuizioni di React ed Elm per lo sviluppo di front-end app multithread JS/WASM.

Per dimostrare la versatilità di Jinja2 (e Liquid/Tera), ho pensato di generare con esso anche questo CV: la repo con il codice (commentato passo-passo) è disponibile su GitHub (=orgcv=).
#+end_src

*** Column 2
**** Skills
# Stampa le keywords ed aggiungi un leggero spazio verticale ogni tre tag.
Print the keywords and add a light vertical space every three tag or when the characters of the single tag exceed 14:

#+name: skills-jinja-latex
#+begin_src latex
{% for skill in skills %}
\cvtag { {{skill}} }
{% if skill | length >= 14 %}

\vspace{+.1cm}
{% endif %}
{% if not loop.last %}
{% if loop.index % 3 == 0 %}

\vspace{+.1cm}

{% endif %}
{% endif %}
{% endfor %}
#+end_src

# Renderizziamo:
Rendering:

#+name: skills-latex
#+begin_src python :session cv-venv :results output latex :var templ=skills-jinja-latex :var ctx=skills-json() :var target=cv-target
skills=json.loads(ctx)
skills = skills["categories"][str(target)]
template = env.from_string(templ)
print(template.render(skills=skills))
#+end_src

#+RESULTS: skills-latex
#+begin_export latex
\cvtag { Pharmaceutical chemistry }

\vspace{+.1cm}
\cvtag { Spectroscopy }
\cvtag { Programming }

\vspace{+.1cm}

\cvtag { Web dev. }
\cvtag { Desktop dev. }
\cvtag { Data viz. }
#+end_export

**** Experiences
#+name: exps-jinja-latex
#+begin_src latex
{% for exp in exps %}
\cvevent{ {{exp.name}} }{ {{ exp.where }} }{ {{ exp.when }} }{}
{% if not loop.last %}

\par\divider

{% endif %}
{% endfor %}
#+end_src

# Renderizziamo:
Rendering:

#+name: exps-latex
#+begin_src python :session cv-venv :results output latex :var templ=exps-jinja-latex :var ctx=exps-json()
template = env.from_string(templ)
print(template.render(exps=json.loads(ctx)))
#+end_src

#+RESULTS: exps-latex
#+begin_export latex
\cvevent{ Tirocinio in Farmacia Ospedaliera }{ Ospedale Gravina di Caltagirone }{ Ottobre 2020 - Luglio 2021 }{}

\par\divider

\cvevent{ Tirocinio per tesi sperimentale }{ Dipartimento di "Chimica Giacomo Ciamician" - Unibo }{ Ottobre 2019 - Maggio 2020 }{}
#+end_export

**** Education
TODO manage more comments.

#+name: edu-jinja-latex
#+begin_src latex
{% for event in edu|reverse %}
\cvevent{ {%- if event.name -%}{{ event.name }}{%- endif -%} }{ {%- if event.where -%}{{ event.where }}{%- endif -%} }{ {%- if event.when -%}{{ event.when }}{%- endif -%} }{}
{% if event.comment -%}
\begin{itemize}
\item {{ event.comment }}
\end{itemize}
{% endif %}

\divider
{% endfor %}
#+end_src

# Renderizziamo:
Rendering:

#+name: edu-latex
#+begin_src python :session cv-venv :results output latex :var templ=edu-jinja-latex :var ctx=edu-json()
template = env.from_string(templ)
print(template.render(edu=json.loads(ctx)))
#+end_src

#+RESULTS: edu-latex
#+begin_export latex
\cvevent{Summer School in Pharmaceutical Analysis}{Campus di Rimini - Palazzo Ruffi-Briolini}{18 Sett. 2017 - 20 Sett. 2017}{}
\begin{itemize}
\item Advanced Analytical Methodologies for Adsorption, Distribution, Metabolism, Excretion and Toxicity (ADMET) Studies
\end{itemize}

\divider
\cvevent{Magistrale a ciclo unico in Chimica e Tecnologia Farmaceutiche}{Dipartimento di Farmacia e Biotecnologie FABIT - Università di Bologna}{Sett. 2014 - In corso}{}

\divider
\cvevent{Diploma Liceo Scientifico}{Liceo Scientifico E. Majorana - Caltagirone}{Sett. 2009 - Giugno 2014}{}

\divider
#+end_export

**** Langs
#+name: langs-jinja-latex
#+begin_src latex
{% for lang in langs %}
\cvskill { {{lang.name}} }{ {{lang.level}} }
{% if not loop.last %}
\divider
{% endif %}
{% endfor %}
#+end_src

# Renderizziamo:
Rendering:

#+name: langs-latex
#+begin_src python :session cv-venv :results output latex :var templ=langs-jinja-latex :var ctx=langs-json()
template = env.from_string(templ)
print(template.render(langs=json.loads(ctx)))
#+end_src

#+RESULTS: langs-latex
#+begin_export latex
\cvskill { Italiano }{ 5 }
\divider
\cvskill { Inglese }{ 4 }
\divider
\cvskill { Francese }{ 1 }
#+end_export

* TODO Markdown
# Qui potrei usare ox-hugo o scrivere direttamente un template con Jinja.
Here I could use ox-hugo or writing directly a Jinja template.

* TODO JSON
I could export every data with a =json.dumps= and adapt the schema to the JSON Resume one.
I don't need this by now.
# Posso esportare tutti i dati con un =json.dumps= e fare il tangling.
# Posso anche adattare i dati allo schema JSON di JSON Resume.

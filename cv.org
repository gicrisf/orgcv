#+title: Literate CV
#+author: Giovanni Crisalfi
#+date: [2022-08-31 mer]
#+startup: overview

#+OPTIONS: tex:t
# #+OPTIONS: drawers:t
# #+OPTIONS: latex:t
# #+OPTIONS: prop:t

#+hugo_base_dir: ~/zwitterio-it/
#+hugo_section: literate-cv
#+hugo_auto_set_lastmod: t
#+export_file_name: index

#+MACRO: more @@html:<!-- more -->@@

Questo file raccoglie tutto il codice necessario a generare il mio CV nelle sue varie versioni.
È anche un esempio di literate programming in org-mode.

{{{more}}}

* Introduzione
Innanzitutto devo rappresentare in qualche modo i dati da riportare nei codici da intessere nelle parti successive. Ho molte opzioni. In JSON non se ne parla proprio. Sarebbe già più accettabile scrivere in TOML, ma in verità le opzioni che mi convincono di più sono due:
- Python dictionaries
- Elisp association lists

Il primo per la sua semplicità, potenziale estensibilità (ogni dato scritto può essere manipolato dagli altri presenti all'interno del blocco, come con la configurazione di Pelican) e buona integrazione con org-babel. Il secondo per l'integrazione assoluta con org-babel ed Emacs in generale.

L'idea è quella di collezionare blocchi di dati modulari, così da esportare varie versioni dello stesso CV con lo stesso Header, per esempio o, comunque, condividendo certi blocchi di dati senza ridondanze di sorta. Scrivendo dizionari Python, potrei iniettare i dati nel testo LaTeX in almeno tre modi:
- Manipolazione delle stringhe classica
- Motore di templating (Jinja2, per esempio, ma questo mi costringerebbe ad avere dipendenze)
- Attraverso PyLaTeX (ma, anche qui, dovrei disporre della dipendenza)

Avere dipendenze esterne non è un grave problema, soprattutto in Python, ma vorrei mantenere questo file quanto più flessibile possibile.
Il bello di Jinja2 è che potrebbe aiutarmi a gestire l'internazionalizzazione (con Babel), quindi credo che il gioco valga la candela.
Potrei ottenere le stesse cose in emacs-lisp, ma temo che risulterebbero meno leggibili.
Inoltre, con Jinja2 posso facilmente esportare anche delle pagine HTML e sarebbe molto molto semplice gestire i for loops, cosa che mi tornerà utile per ripetere gli stessi template su progetti, lingue ecc. su tutte le versioni del CV (LaTeX, HTML, Markdown...). Considerate tutte queste premesse, non c'è dubbio che un motore di templating sia esattamente quello che ci serve in questa situazione per mantenere il codice leggibile e flessibile.

Non ci resta che costruire un ambiente Python adatto.

* Python environment
#+begin_quote
ATTENZIONE!

Per i più disattenti, il CV non può essere renderizzato senza alcune piccole dipendenze Python.
#+end_quote

Come si installa Jinja2?
[[https://jinja.palletsprojects.com/en/3.1.x/intro/#installation][Basta dare un occhio alla documentazione]].

** Installazione globale
Usare un [[https://packaging.python.org/tutorials/installing-packages/#creating-virtual-environments][virtual environment]] è preferibile, ma installare globalmente è più semplice:

#+begin_src bash
$ pip install Jinja2
#+end_src

Per il supporto multilingua, bisogna anche installare Babel, che non è automaticamente incluso tra le dipendenze.

#+begin_src bash
$ pip install Babel
#+end_src

Io preferisco usare un virtual environment, ma lascio comunque qui i comandi base per chi volesse semplificarsi la vita.

** Virtualenv
In condizioni normali, questo è quello che faremmo per creare un virtual environment (chiamato =venv=).

#+begin_src bash
$ mkdir myproject
$ cd myproject
$ virtualenv venv
New python executable in venv/bin/python
Installing distribute............done.
#+end_src

Questo per attivarlo:
#+begin_src bash
$ . venv/bin/activate
#+end_src

Anziché attivarlo, limitiamoci a creare un virtual environment inequivocabilmente utile alla produzione del CV e lasciamolo in attesa.

#+begin_src bash
$ virtualenv cv-venv
#+end_src

# TODO: scriptare all'interno di questo file la creazione dell'environment.

** Virtualenv ed Emacs
In Emacs le cose si fanno un po' più complicate.
Da StackOverlow:
- [[https://stackoverflow.com/questions/38535499/how-to-setup-emacs-to-use-a-given-python-virtualenv][How to setup Emacs to use a given Python virtualenv?]]
- [[https://stackoverflow.com/questions/53992886/org-babel-python-environment-setup][org-babel python environment setup]]

Anche sulla base di [[https://justin.abrah.ms/dotfiles/emacs.html][alcune literate conf di Emacs]], pare che l'opzione più quotata sia utilizzare un pacchetto Emacs che fa da tramite, [[https://github.com/jorgenschaefer/pyvenv][pyvenv]].

#+begin_quote
The main entry points are pyvenv-activate, which queries the user for a virtual environment directory to activate, and pyvenv-workon, which queries for a virtual environment in $WORKON_HOME (from virtualenvwrapper.sh).
#+end_quote

Per installarlo classicamente, aggiungere questo ad =init.el=:

#+begin_src emacs-lisp
(use-package pyvenv
  :ensure t
  :config
  (pyvenv-mode t)
#+end_src

Io, invece, installerò attraverso la mia literate configuration su Doom Emacs.

E se volessimo selezionare un interpreter in particolare?
[[https://blog.fredrikmeyer.net/2020/08/26/emacs-python-venv.html][Fredrik Meyer sul suo blog offre una soluzione]]:

#+begin_src emacs-lisp
;; Set correct Python interpreter
(setq pyvenv-post-activate-hooks
      (list (lambda ()
              (setq python-shell-interpreter (concat pyvenv-virtual-env "bin/python3")))))

(setq pyvenv-post-deactivate-hooks
      (list (lambda ()
              (setq python-shell-interpreter "python3")))))
#+end_src

** Virtualenv ed Emacs/Org-mode
Org-mode aggiunge un ulteriore layer che ci complica un pochino le cose.

https://emacs.stackexchange.com/questions/24267/using-org-babel-to-enable-virtualenv

#+BEGIN_SRC elisp :session cv-venv :results silent
;; doesn't return any value or output, so I'm silencing this block
(pyvenv-activate "~/Projects/my-org-resume/cv-venv")
#+END_SRC

Verifichiamo che sia stato attivato (result is silenced, look at the minibuffer).

#+BEGIN_SRC sh :session cv-venv :results silent
echo $VIRTUAL_ENV
which python
#+END_SRC

#+BEGIN_SRC python :results silent :session cv-venv
import sys
print('\n'.join(sys.path))
#+END_SRC

Vediamo se l'importazione dei nuovi pacchetti è riuscita:
#+begin_src python :results output :session cv-venv
try:
    import jinja2
    import babel
    print("succeded")
except:
    print("failed")
#+end_src

#+RESULTS:
: succeded

Bene, ora possiamo procedere.

* Jinja environment
[[https://jinja.palletsprojects.com/en/3.1.x/api/#basics][Dalla documentazione di Jinja2]]:

#+begin_quote
This will create a template environment with a loader that looks up templates in the templates folder inside the yourapp Python package (or next to the yourapp.py Python module). It also enables autoescaping for HTML files. This loader only requires that yourapp is importable, it figures out the absolute path to the folder for you.
#+end_quote

#+begin_src python :session cv-venv
from jinja2 import Environment, PackageLoader, select_autoescape
env = Environment(
    loader=PackageLoader("orgcv"),
    autoescape=select_autoescape()
)
#+end_src

#+RESULTS:

#+begin_quote
To load a template from this environment, call the get_template() method, which returns the loaded Template.
#+end_quote

#+begin_src python
template = env.get_template("mytemplate.html")
#+end_src

Non ho bisogno di scrivere necessariamente i template in file a parte.
[[https://jinja.palletsprojects.com/en/3.1.x/api/#jinja2.Template][Potrei utilizzare il constructor di Jinja2]].

#+begin_quote
To render it with some variables, call the render() method.
#+end_quote

#+begin_src python
print(template.render(the="variables", go="here"))
#+end_src

#+begin_quote
Using a template loader rather than passing strings to Template or Environment.from_string() has multiple advantages. Besides being a lot easier to use it also enables template inheritance.
#+end_quote

* Data
** Personal Info
Usiamo "context" come nome per il nostro dizionario ([[https://realpython.com/primer-on-jinja-templating/][è una convenzione]]):

#+begin_quote
Note: Using context as a name for the collection that stores the variables for a template is a convention. That said, you can name the dictionary differently if you prefer.
#+end_quote

Intendiamo ottenere un dizionario di questo genere:

#+begin_src python :session cv-venv
basics = {
    "name": "Giovanni Crisalfi",
    "photo": "propic-ciliegio.jpg",
    # ...
    "driving": "Patente B",
}
#+end_src

Potremmo scrivere i dati direttamente nel dizionario e far comunicare i blocchi, ma poi dipenderemmo dall'esecuzione del codice in sequenza per passare i dati da un blocco all'altro.

È più comodo passare i dati attraverso le variabili org-babel, quindi generare i dati a partire da una tabella in org-mode. Inoltre, è anche più facile da manipolare.
Possiamo inserire le stringhe tra virgolette o senza, non fa differenza.

#+begin_quote
ATTENZIONE!

La tabella qui sotto è quella che va modificata. Il dizionario poco sopra è solo a titolo d'esempio.
#+end_quote

#+name: personalinfo-table
| "name"     | "Giovanni Crisalfi"                |
| "photo"    | "propic-ciliegio.jpg"              |
| "tagline"  | "Studente"                         |
| "homepage" | "www.zwitterio.it"                 |
| "email"    | "giovanni.crisalfi@protonmail.com" |
| "phone"    | "+39 3331604917"                   |
| "location" | "Caltagirone, CT"                  |
| "github"   | "gicrisf"                          |
| "twitter"  | "gicrisf"                          |
| "dob"      | "27 Dicembre 1995"                 |
| "driving"  | "Patente B"                        |

La tabella mi produce una lista di righe. Per ogni riga troviamo una lista degli elementi nella colonna indicata. Possiamo convertirla in dizionario python in una seconda fase, così:

#+begin_src python :results output :var table=personalinfo-table
# Convert to dictionary
basics = {}
for elem in table:
    basics[elem[0]] = elem[1]

print(basics)
#+end_src

#+RESULTS:
: {'name': 'Giovanni Crisalfi', 'photo': 'propic-ciliegio.jpg', 'tagline': 'Studente', 'homepage': 'www.zwitterio.it', 'email': 'giovanni.crisalfi@protonmail.com', 'phone': '+39 3331604917', 'location': 'Caltagirone, CT', 'github': 'gicrisf', 'twitter': 'gicrisf', 'dob': '27 Dicembre 1995', 'driving': 'Patente B'}

Il problema di questa soluzione è che non si adatta alle fasi successive, in cui le relazioni sono meno tabulabili, per esempio quando tocca occuparsi dei progetti, le esperienze lavorative.
E allora la cosa più ragionevole sembra quella di scrivere:
- JSON/Python dict
- Alist/Plist in Emacs-lisp

Cioè delle strutture più flessibili.

Credo che la cosa più conveniente sia continuare a lavorare in Python, quindi coi python dictionaries, ma passando i dati da un blocco all'altro come stringhe JSON.
In questo modo evitiamo di fare casini durante i trasferimenti, creiamo un sistema che potrebbe potenzialmente essere gestito fuori da org-mode (come [[https://jsonresume.org/][JSON resume]]) ed evitiamo pure di scrivere lisp. Vorrei che questo testo sia comprensibile a quante più persone possibili e so bene che lisp tende ad intimidire qualcuno. Teniamoci sul mainstream, insomma.

Cominciamo con l'aggiungere i dati personali dalla tabella qui sopra.

#+name: personalinfo-json
#+begin_src python :sessions cv-venv :results output :var basics_table=personalinfo-table
import json
basics = {}
for elem in basics_table:
    basics[elem[0]] = elem[1]

print(json.dumps(basics))
#+end_src

#+RESULTS: personalinfo-json
: {"name": "Giovanni Crisalfi", "photo": "propic-ciliegio.jpg", "tagline": "Studente", "homepage": "www.zwitterio.it", "email": "giovanni.crisalfi@protonmail.com", "phone": "+39 3331604917", "location": "Caltagirone, CT", "github": "gicrisf", "twitter": "gicrisf", "dob": "27 Dicembre 1995", "driving": "Patente B"}

# Il problema di questo metodo è che rende l'assemblaggio del JSON un po' noioso ed inutilmente sequenziale. Sarebbe assai più comodo se organizzassimo un dizionario python senza passare da JSON e poi facessimo un dump finale in caso di necessità.
# La migliore strategia che mi viene in mente per lavorare in python e ridurre questa intricata filatura di stringhe (e sempre evitando l'esecuzione di un blocco unico sul modello dei Jupyter Notebooks) è fare uso della sintassi noweb ed integrare nello stesso blocco sia il dato che la funzione che lo esporta.

Cosa ce ne facciamo di questo risultato?
Aspettiamo di arrivare alla fine ed integriamo tutti i dizionari in un unico dizionario onnicomprensivo che faccia poi da contesto per la generazione in Jinja2.
L'importazione avverrà così, convertendo ogni JSON parziale in un dizionario python che sarà assegnato a una variabile, la quale potrà facilmente essere inclusa in un altro dizionario.
In questo modo, ogni cambiamento sarà modulare e non richiederà l'intervento su tutti i blocchi di volta in volta.

#+begin_src python :results output :noweb no-export eval
import json
basics = json.loads(
    """
    <<personalinfo-json()>>
    """
)

print(imported)
#+end_src

#+RESULTS:
: {'name': 'Giovanni Crisalfi', 'photo': 'propic-ciliegio.jpg', 'tagline': 'Studente', 'homepage': 'www.zwitterio.it', 'email': 'giovanni.crisalfi@protonmail.com', 'phone': '+39 3331604917', 'location': 'Caltagirone, CT', 'github': 'gicrisf', 'twitter': 'gicrisf', 'dob': '27 Dicembre 1995', 'driving': 'Patente B'}

Questo metodo consente anche di importare delle semplici stringhe con maggiore facilità, come vedremo coi "personal statement".
Purtroppo, c'è un limite alla memoria in stack che possiamo pretendere noweb usi per conservare le stringhe generate, quindi in base alla situazione potremmo ottenere questo errore:

#+begin_quote
rx--translate-**: Lisp nesting exceeds ‘max-lisp-eval-depth’
#+end_quote

Bisogna evitare un nesting eccessivo, ma questo torna utile anche per mantenere il codice pulito.

** Personal Statements
*** IT
#+name: personal-statement-it
#+begin_src org :results output
Studente di CTF appassionato di spettroscopia e simulazioni computazionali.
Sostenitore dell'Open Source, vivo su Linux e scrivo sia codice che prosa su Emacs.
Mi interesso di epistemologia, cinema, fumetti e altre lettere.
#+end_src

*** EN
#+name: personal-statement-en
#+begin_src org :results output
Medicinal chemistry student at Unibo • Into spectroscopy and radicals • Linux citizen • Coding in Rust • Scripting in Python/Lisp • Reading and writing around.
#+end_src

** Projects
In questo blocco è possibile inserire o rimuovere i progetti che vogliamo mostrare nell'esportato.

#+name: projects-json
#+begin_src python :session cv-venv :results output :noweb no-export eval :var esrafel=esrafel-project() :var zhuia=zhuia-project() :var gotosi=gotosi-project() :var unsplash=unsplash-project
projects = [
    esrafel,
    zhuia,
#    gotosi,
    unsplash
]
projects = [json.loads(x) for x in projects]

print(json.dumps(projects))
#+end_src

#+RESULTS: projects-json
: [{"name": "Esrafel", "description": "Software for least-squares fitting of ESR/EPR spectra with Monte Carlo methods", "when": "Marzo 2020 - Marzo 2022", "link": {"icon": "Github", "text": "gicrisf/esrafel", "href": "https://github.com/gicrisf/esrafel"}, "tags": ["Desktop dev.", "Rust", "GTK", "Spettroscopia"]}, {"name": "Zhuia", "description": "An elegant but still playful theme for Zola", "when": "Feb. 2022 - Marzo 2022", "link": {"icon": "Github", "text": "gicrisf/zhuia", "href": "https://github.com/gicrisf/zhuia"}, "tags": ["Web dev.", "Rust", "Zola", "Tera", "Liquid", "Jinja2"]}, {"name": "Gotosi", "description": "Isotope oriented periodic table of elements", "when": "Feb. 2021 - Maggio 2021", "link": {"icon": "Github", "text": "gicrisf/gotosi", "href": "https://github.com/gicrisf/gotosi"}, "tags": ["Desktop dev.", "Vala", "C", "GTK", "Chemistry"]}, {"name": "3D renders", "description": "Bio/Chem molecular renders for fun and blogging", "when": "", "link": {"icon": "Unsplash", "text": "@gicrisf", "href": "https://unsplash.com/@gicrisf"}, "tags": ["Grafica", "Chimica", "GIMP", "VMD"]}]

*** Esrafel
#+name: esrafel-project
#+begin_src python :session cv-venv :results output
esrafel = {
    "name": "Esrafel",
    "description": "Software for least-squares fitting of ESR/EPR spectra with Monte Carlo methods",
    "when": "Marzo 2020 - Marzo 2022",
    "link": {
        "icon": "Github",
        "text": "gicrisf/esrafel",
        "href": "https://github.com/gicrisf/esrafel"
    },
    "tags": ["Desktop dev.", "Rust", "GTK", "Spettroscopia"]
}

print(json.dumps(esrafel))
#+end_src

#+RESULTS: esrafel-project
: {"name": "Esrafel", "description": "Software for least-squares fitting of ESR/EPR spectra with Monte Carlo methods", "when": "Marzo 2020 - Marzo 2022", "link": {"icon": "Github", "text": "gicrisf/esrafel", "href": "https://github.com/gicrisf/esrafel"}, "tags": ["Desktop dev.", "Rust", "GTK", "Spettroscopia"]}

**** TODO Decoratore
Per non scrivere sempre =print(json.dumps(X))=, potrei scrivere un decoratore.

*** Zhuia
#+name: zhuia-project
#+begin_src python :session cv-venv :results output
zhuia = {
    "name": "Zhuia",
    "description": "An elegant but still playful theme for Zola",
    "when": "Feb. 2022 - Marzo 2022",
    "link": {
        "icon": "Github",
        "text": "gicrisf/zhuia",
        "href": "https://github.com/gicrisf/zhuia"
    },
    "tags": ["Web dev.", "Rust", "Zola", "Tera", "Liquid", "Jinja2"]
}

print(json.dumps(zhuia))
#+end_src

#+RESULTS: zhuia-project
: {"name": "Zhuia", "description": "An elegant but still playful theme for Zola", "when": "Feb. 2022 - Marzo 2022", "link": {"icon": "Github", "text": "gicrisf/zhuia", "href": "https://github.com/gicrisf/zhuia"}, "tags": ["Web dev.", "Rust", "Zola", "Tera", "Liquid", "Jinja2"]}

*** Gotosi
#+name: gotosi-project
#+begin_src python :session cv-venv :results output
gotosi = {
    "name": "Gotosi",
    "description": "Isotope oriented periodic table of elements",
    "when": "Feb. 2021 - Maggio 2021",
    "link": {
        "icon": "Github",
        "text": "gicrisf/gotosi",
        "href": "https://github.com/gicrisf/gotosi"
    },
    "tags": ["Desktop dev.", "Vala", "C", "GTK", "Chemistry"]
}

print(json.dumps(gotosi))
#+end_src

#+RESULTS: gotosi-project
: {"name": "Gotosi", "description": "Isotope oriented periodic table of elements", "when": "Feb. 2021 - Maggio 2021", "link": {"icon": "Github", "text": "gicrisf/gotosi", "href": "https://github.com/gicrisf/gotosi"}, "tags": ["Desktop dev.", "Vala", "C", "GTK", "Chemistry"]}

*** Unsplash
#+name: unsplash-project
#+begin_src python :session cv-venv :results output
unsplash = {
    "name": "3D renders",
    "description": "Bio/Chem molecular renders for fun and blogging",
    "when": "",
    "link": {
        "icon": "Unsplash",
        "text": "@gicrisf",
        "href": "https://unsplash.com/@gicrisf"
    },
    "tags": ["Grafica", "Chimica", "GIMP", "VMD"]
}

print(json.dumps(unsplash))
#+end_src

#+RESULTS: unsplash-project
: {"name": "3D renders", "description": "Bio/Chem molecular renders for fun and blogging", "when": "", "link": {"icon": "Unsplash", "text": "@gicrisf", "href": "https://unsplash.com/@gicrisf"}, "tags": ["Grafica", "Chimica", "GIMP", "VMD"]}

** Seminari
#+name: seminari-json
#+begin_src python :session cv-venv :results output :noweb no-export eval :var festival_scienza_medica=festival-scienza-medica-event() :var sitox=sitox-event :var chemistry_world_driving=chemistry-world-driving-event() :var chemistry_world_accelerating=chemistry-world-accelerating-event()
seminari = []
seminari.append(festival_scienza_medica)
seminari.append(sitox)
seminari.append(chemistry_world_driving)
seminari.append(chemistry_world_accelerating)

seminari = [json.loads(x) for x in seminari]
print(json.dumps(seminari))
#+end_src

#+RESULTS: seminari-json
: [{"name": "Festival della Scienza Medica", "where": "Palazzo Re Enzo - piazza Nettuno 1 - Bologna", "when": "Anni: 2016 - 2017 - 2018 - 2019"}, {"name": "18\u00b0 Congresso Nazionale Sitox", "where": "Savoia Hotel Regency - Via del Pilastro 2 - 40127 Bologna", "when": "10 Apr. 2018 - 13 Apr. 2018"}, {"name": "Driving the development of bio-based polymers with molecular simulation", "where": "Chemistry World Webinar", "when": "13 Apr. 2022"}, {"name": "Accelerating first-in-class and best-in-class programs using a large-scale digital chemistry strategy", "where": "Chemistry World Webinar", "when": "24 Maggio 2022"}]

*** Festival della scienza medica
#+name: festival-scienza-medica-event
#+begin_src python :session cv-venv :results output
festival_scienza_medica = {
    "name": "Festival della Scienza Medica",
    "where": "Palazzo Re Enzo - piazza Nettuno 1 - Bologna",
    "when": "Anni: 2016 - 2017 - 2018 - 2019"
}

print(json.dumps(festival_scienza_medica))
#+end_src

#+RESULTS: festival-scienza-medica-event
: {"name": "Festival della Scienza Medica", "where": "Palazzo Re Enzo - piazza Nettuno 1 - Bologna", "when": "Anni: 2016 - 2017 - 2018 - 2019"}

*** SITOX
#+name: sitox-event
#+begin_src python :session cv-venv :results output
sitox = {
    "name": "18° Congresso Nazionale Sitox",
    "where": "Savoia Hotel Regency - Via del Pilastro 2 - 40127 Bologna",
    "when": "10 Apr. 2018 - 13 Apr. 2018",
}

print(json.dumps(sitox))
#+end_src

#+RESULTS: sitox-event
: {"name": "18\u00b0 Congresso Nazionale Sitox", "where": "Savoia Hotel Regency - Via del Pilastro 2 - 40127 Bologna", "when": "10 Apr. 2018 - 13 Apr. 2018"}

*** Chemistry World
#+name: chemistry-world-driving-event
#+begin_src python :session cv-venv :results output
chemistry_world_driving = {
    "name": "Driving the development of bio-based polymers with molecular simulation",
    "where": "Chemistry World Webinar",
    "when": "13 Apr. 2022",
}

print(json.dumps(chemistry_world_driving))
#+end_src

#+RESULTS: chemistry-world-driving-event
: {"name": "Driving the development of bio-based polymers with molecular simulation", "where": "Chemistry World Webinar", "when": "13 Apr. 2022"}

#+name: chemistry-world-accelerating-event
#+begin_src python :session cv-venv :results output
chemistry_world_accelerating = {
    "name": "Accelerating first-in-class and best-in-class programs using a large-scale digital chemistry strategy",
    "where": "Chemistry World Webinar",
    "when": "24 Maggio 2022",
}

print(json.dumps(chemistry_world_accelerating))
#+end_src

#+RESULTS: chemistry-world-accelerating-event
: {"name": "Accelerating first-in-class and best-in-class programs using a large-scale digital chemistry strategy", "where": "Chemistry World Webinar", "when": "24 Maggio 2022"}

** Skills
*** General
#+name: general-skills-json
#+begin_src python :session cv-venv :results output
skills = {
    "name": "Skills",
    "keywords": ["Pharmaceutical chemistry",
                 "Spectroscopy",
                 "Programming",
                 "Web dev.",
                 "Desktop dev.",
                 "Data viz."]
}

print(json.dumps(skills))
#+end_src

#+RESULTS: general-skills-json
: {"name": "Skills", "keywords": ["Pharmaceutical chemistry", "Spectroscopy", "Programming", "Web dev.", "Desktop dev.", "Data viz."]}

*** Web
#+name: web-skills-json
#+begin_src python :session cv-venv :results output
web = {
    "name": "Web Development",
    "keywords": ["HTML5",
                 "CSS",
                 "JS/Typescript",
                 "Liquid",
                 "Jinja2",
                 "Tera",
                 "Twig",
                 "Zola",
                 "Pelican",
                 "Jamstack"]
}

print(json.dumps(web))
#+end_src

*** CTF
#+name: pharma-skills-json
#+begin_src python :session cv-venv :results output
pharma = {
    "name": "Pharma",
    "keywords": ["Pharmaceutical Analysis",
                 "Organic Chemistry",
                 "EPR/NMR Spectroscopy",
                 "Stereochemistry",
                 "Data viz."]
}

print(json.dumps(pharma))
#+end_src

#+RESULTS: pharma-skills-json
: {"name": "Pharma", "keywords": ["Pharmaceutical Analysis", "Organic Chemistry", "EPR/NMR Spectroscopy", "Stereochemistry", "Data viz."]}

*** Programming
#+name: programming-skills-json
#+begin_src python :session cv-venv :results output
programming = {
    "name": "Programming",
    "keywords": ["Rust",
                 "Python",
                 "Lisp",
                 "Vala",
                 "C",
                 "Git",
                 "Php"]
}

print(json.dumps(programming))
#+end_src

#+RESULTS: programming-skills-json
: {"name": "Programming", "keywords": ["Rust", "Python", "Lisp", "Vala", "C", "Git", "Php"]}

** Esperienze
#+name: exps-json
#+begin_src python :session cv-venv :results output :noweb no-export eval :var tirocinio=farmacia-ospedaliera-exp() :var tesi=tesi-sperimentale-exp()
exps = [
    tirocinio,
    tesi,
]

exps = [json.loads(x) for x in exps]

print(json.dumps(exps))
#+end_src

#+RESULTS: exps-json
: [{"name": "Tirocinio in Farmacia Ospedaliera", "where": "Ospedale Gravina di Caltagirone", "when": "Ottobre 2020 - Luglio 2021"}, {"name": "Tirocinio per tesi sperimentale", "where": "Dipartimento di \"Chimica Giacomo Ciamician\" - Unibo", "when": "Ottobre 2019 - Maggio 2020"}]

*** Farmacia ospedaliera
#+name: farmacia-ospedaliera-exp
#+begin_src python :session cv-venv :results output
farmacia_ospedaliera = {
    "name": "Tirocinio in Farmacia Ospedaliera",
    "where": "Ospedale Gravina di Caltagirone",
    "when": "Ottobre 2020 - Luglio 2021",
}

print(json.dumps(farmacia_ospedaliera))
#+end_src

#+RESULTS: farmacia-ospedaliera-exp
: {"name": "Tirocinio in Farmacia Ospedaliera", "where": "Ospedale Gravina di Caltagirone", "when": "Ottobre 2020 - Luglio 2021"}

*** Tesi sperimentale
#+name: tesi-sperimentale-exp
#+begin_src python :session cv-venv :results output
tesi_sperimentale = {
    "name": "Tirocinio per tesi sperimentale",
    "where": "Dipartimento di \"Chimica Giacomo Ciamician\" - Unibo",
    "when": "Ottobre 2019 - Maggio 2020",
}

print(json.dumps(tesi_sperimentale))
#+end_src

#+RESULTS: tesi-sperimentale-exp
: {"name": "Tirocinio per tesi sperimentale", "where": "Dipartimento di \"Chimica Giacomo Ciamician\" - Unibo", "when": "Ottobre 2019 - Maggio 2020"}

** Education

#+name: edu-json
#+begin_src python :session cv-venv :results output :noweb no-export eval :var diploma=diploma-scientifico-edu() :var ctf=ctf-edu() :var adme=adme-edu()
edu_list = [
    diploma,
    ctf,
    adme,
]

edu = [json.loads(x) for x in edu_list]

print(json.dumps(edu))
#+end_src

#+RESULTS: edu-json
: [{"name": "Diploma Liceo Scientifico", "where": "Liceo Scientifico E. Majorana - Caltagirone", "when": "Sett. 2009 - Giugno 2014"}, {"name": "Magistrale a ciclo unico in Chimica e Tecnologia Farmaceutiche", "where": "Dipartimento di Farmacia e Biotecnologie FABIT - Universit\u00e0 di Bologna", "when": "Sett. 2014 - In corso"}, {"name": "Summer School in Pharmaceutical Analysis", "where": "Campus di Rimini - Palazzo Ruffi-Briolini", "when": "18 Sett. 2017 - 20 Sett. 2017", "comment": "Advanced Analytical Methodologies for Adsorption, Distribution, Metabolism, Excretion and Toxicity (ADMET) Studies"}]

*** Diploma Scientifico
#+name: diploma-scientifico-edu
#+begin_src python :session cv-venv :results output
diploma_scientifico = {
    "name": "Diploma Liceo Scientifico",
    "where": "Liceo Scientifico E. Majorana - Caltagirone",
    "when": "Sett. 2009 - Giugno 2014",
}

print(json.dumps(diploma_scientifico))
#+end_src

#+RESULTS: diploma-scientifico-edu
: {"name": "Diploma Liceo Scientifico", "where": "Liceo Scientifico E. Majorana - Caltagirone", "when": "Sett. 2009 - Giugno 2014"}

*** CTF
#+name: ctf-edu
#+begin_src python :session cv-venv :results output
ctf = {
    "name": "Magistrale a ciclo unico in Chimica e Tecnologia Farmaceutiche",
    "where": "Dipartimento di Farmacia e Biotecnologie FABIT - Università di Bologna",
    "when": "Sett. 2014 - In corso",
}

print(json.dumps(ctf))
#+end_src

#+RESULTS: ctf-edu
: {"name": "Magistrale a ciclo unico in Chimica e Tecnologia Farmaceutiche", "where": "Dipartimento di Farmacia e Biotecnologie FABIT - Universit\u00e0 di Bologna", "when": "Sett. 2014 - In corso"}

*** Summer School in Pharma Analysis
#+name: adme-edu
#+begin_src python :session cv-venv :results output
pharma_analysis_summer_school = {
    "name": "Summer School in Pharmaceutical Analysis",
    "where": "Campus di Rimini - Palazzo Ruffi-Briolini",
    "when": "18 Sett. 2017 - 20 Sett. 2017",
    "comment": "Advanced Analytical Methodologies for Adsorption, Distribution, Metabolism, Excretion and Toxicity (ADMET) Studies"
}

print(json.dumps(pharma_analysis_summer_school))
#+end_src

#+RESULTS: adme-edu
: {"name": "Summer School in Pharmaceutical Analysis", "where": "Campus di Rimini - Palazzo Ruffi-Briolini", "when": "18 Sett. 2017 - 20 Sett. 2017", "comment": "Advanced Analytical Methodologies for Adsorption, Distribution, Metabolism, Excretion and Toxicity (ADMET) Studies"}

*** TODO 24 CFU
*** TODO ONSCI
Officina di narrazione della Scienza.
7-14 settembre a Bologna.
Dipartimento di Fisica e Astronomia Unibo.
Tempi e luoghi per pensare con la scienza: nuovi linguaggi per l'educazione STEM.

** Langs
#+name: langs-json
#+begin_src python :session cv-venv :results output
langs = [{"name": "Italiano", "level": "5" },
         {"name": "Inglese", "level": "4"},
         {"name": "Francese", "level": "1"}]

print(json.dumps(langs))
#+end_src

#+RESULTS: langs-json
: [{"name": "italiano", "level": 5}, {"name": "Inglese", "level": 4}, {"name": "Francese", "level": 1}]

* LaTeX
L'idea è di esportare tutto con org-exporter per LaTeX, wrappando in blocchi org-mode che a loro volta wrappino del LaTeX puro. Così facendo, possiamo sfruttare esportare direttamente da questo documento, senza avviare =pdflatex= da terminale e anche impiegare le impostazioni interne di org-latex.

#+begin_src emacs-lisp
(setq org-latex-logfiles-extensions (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl" "xmpi" "run.xml" "bcf")))
#+end_src

Per fare prima, aggiungo direttamente questa variabile alla configurazione generale di Emacs.

Il LaTeX finale (come tutti i LaTeX) sarà costituito da una testa (=head=) e un documento (=document=):

#+begin_src latex :noweb no-export :tangle cv.tex
<<head-latex>>

<<document-latex>>
#+end_src

** Dipendenze
Prima di tentare la conversione in pdf (es. con =pdflatex=) ricorda che sono necessarie le seguenti dipendenze.

*** Fonts
In effetti, su AUR si trova =texlive-fonts-fontawesome=...

#+begin_src bash
yay texlive-fonts-fontawesome
#+end_src

... ma visto che ci serve anche Roboto, facciamo prima ad installare il pacchetto coi font:

#+begin_src bash
sudo pacman -S texlive-fontsextra
#+end_src

*** Bibtex
#+begin_src bash
sudo pacman -S texlive-bibtexextra
#+end_src

** Head
*** Overview
#+name: head-latex
#+begin_src latex :noweb no-export
% Created 2022-07-27 mer 04:05
% Intended LaTeX compiler: pdflatex

<<class-latex>>

<<layout-latex>>

<<fonts-latex>>

<<colors-latex>>

<<bullets-latex>>

<<font-packages-latex>>

<<columns-latex>>

<<footnotes-latex>>

<<exporter-latex>>
#+end_src

*** Class
#+name: class-latex
#+begin_src latex
\documentclass[10pt,a4paper,ragged2e,withhyper]{altacv}
#+end_src

*** Layout
#+name: layout-latex
#+begin_src latex
% Change the page layout if you need to
\geometry{left=1.25cm,right=1.25cm,top=1.5cm,bottom=1.5cm,columnsep=1.2cm}
#+end_src

*** Fonts
**** Commands
#+name: fonts-latex
#+begin_src latex
% Use roboto and lato for fonts
\renewcommand{\familydefault}{\sfdefault}

% Change some fonts, if necessary
\renewcommand{\namefont}{\Huge\rmfamily\bfseries}
\renewcommand{\personalinfofont}{\footnotesize}
\renewcommand{\cvsectionfont}{\LARGE\rmfamily\bfseries}
\renewcommand{\cvsubsectionfont}{\large\bfseries}
#+end_src

**** Packages
#+name: font-packages-latex
#+begin_src latex
\usepackage[rm]{roboto}
\usepackage[defaultsans]{lato}
#+end_src

*** Colors
#+name: colors-latex
#+begin_src latex
% Change the colours if you want to
\definecolor{SlateGrey}{HTML}{2E2E2E}
\definecolor{LightGrey}{HTML}{666666}
\definecolor{DarkPastelRed}{HTML}{450808}
\definecolor{PastelRed}{HTML}{8F0D0D}
\definecolor{GoldenEarth}{HTML}{E7D192}

\colorlet{name}{black}
\colorlet{tagline}{PastelRed}
\colorlet{heading}{DarkPastelRed}
\colorlet{headingrule}{GoldenEarth}
\colorlet{subheading}{PastelRed}
\colorlet{accent}{PastelRed}
\colorlet{emphasis}{SlateGrey}
\colorlet{body}{LightGrey}
#+end_src

*** Bullets
#+name: bullets-latex
#+begin_src latex
% Change the bullets for itemize and rating marker
% for cvskill if you want to
\renewcommand{\itemmarker}{{\small\textbullet}}
\renewcommand{\ratingmarker}{\faCircle}
#+end_src

*** Columns
#+name: columns-latex
#+begin_src latex
\usepackage{paracol}
\columnratio{0.6} % Set the left/right column width ratio to 6:4.
#+end_src

*** Footnotes
#+name: footnotes-latex
#+begin_src latex
\usepackage[bottom]{footmisc}
#+end_src

*** TODO Bibliography
#+name: bib-latex
#+begin_src latex
\DeclareNameAlias{sortname}{given-family}

\addbibresource{aidan.bib}

\usepackage[style=trad-abbrv,sorting=none,sortcites=true,doi=false,url=false,giveninits=true,hyperref]{biblatex}
#+end_src

Per il momento elimino perché:
#+begin_quote
! LaTeX Error: Option clash for package biblatex.
#+end_quote

*** Exporter
#+name: exporter-latex
#+begin_src latex
\author{Giovanni Crisalfi}
\date{\today}
\title{}
#+end_src

** Document
*** Overview
#+name: document-latex
#+begin_src latex :noweb no-export
\begin{document}

<<personalinfo-latex()>>

\makecvheader

\begin{paracol}{2}

<<personal-statement-latex()>>

\vspace{.1cm}

\cvsection{Progetti}
\label{sec:org9314928}

<<projects-latex()>>

\cvsection{Seminari}
\label{sec:org1d737ad}

<<seminari-latex()>>

\switchcolumn

\cvsection{Competenze}
\label{sec:orga689fa6}

<<skills-latex()>>

\cvsection{Esperienze}
\label{sec:org5a7829c}

<<exps-latex()>>

\cvsection{Istruzione}
\label{sec:org75d0adb}

<<edu-latex()>>

\cvsection{Lingue}

<<langs-latex()>>

\end{paracol}
\end{document}
#+end_src

*** Header
**** Personal Info
Vogliamo ottenere un risultato del genere:

#+begin_src latex
\name{Giovanni Crisalfi}
\photoR{2.8cm}{propic-ciliegio.jpg}
\tagline{Studente}

\personalinfo{
  % ...
}
#+end_src

Scriviamo un template:
#+name: personalinfo-jinja-latex
#+begin_src latex :results output
\name{ {{ctx.name}} }
\photoR{2.8cm}{ {{ctx.photo}} }
\tagline{ {{ctx.tagline}} }

\personalinfo{
  \homepage{ {{ctx.homepage}} }
  \email{ {{ctx.email}} }
  \phone{ {{ctx.phone}} }
  \location{ {{ctx.location}} }
  \github{ {{ctx.github}} }
  \twitter{ {{ctx.twitter}} }
  % \linkedin{  }
  \dob{ {{ctx.dob}} }
  \driving{ {{ctx.driving}} }
}
#+end_src

Intanto verifichiamo che Jinja2 stia funzionando come si deve:

#+begin_src python :results output :var context=personalinfo-table
import jinja2

environment = jinja2.Environment()
template = environment.from_string("Hello, {{ name }}!")

print(template.render(name="World"))
#+end_src

#+RESULTS:
: Hello, World!

Ora renderizziamo il primo template:
#+name: personalinfo-latex
#+begin_src python :session cv-venv :results output latex :var templ=personalinfo-jinja-latex :var ctx=personalinfo-json()
ctx=json.loads(ctx)
env = jinja2.Environment()
template = env.from_string(templ)
print(template.render(ctx=ctx))
#+end_src

#+RESULTS: personalinfo-latex
#+begin_export latex
\name{ Giovanni Crisalfi }
\photoR{2.8cm}{ propic-ciliegio.jpg }
\tagline{ Studente }

\personalinfo{
  \homepage{ www.zwitterio.it }
  \email{ giovanni.crisalfi@protonmail.com }
  \phone{ +39 3331604917 }
  \location{ Caltagirone, CT }
  \github{ gicrisf }
  \twitter{ gicrisf }
  % \linkedin{  }
  \dob{ 27 Dicembre 1995 }
  \driving{ Patente B }
}
#+end_export

*** Column 1
**** Personal Statement
#+name: personal-statement-latex
#+begin_src latex :noweb no-export
\begin{quote}
<<personal-statement-it>>
\end{quote}
#+end_src

#+RESULTS: personal-statement-latex
#+begin_export latex
\begin{quote}
Studente di CTF appassionato di spettroscopia e simulazioni computazionali.
Sostenitore dell'Open Source, vivo su Linux e scrivo sia codice che prosa su Emacs.
Mi interesso di epistemologia, cinema, fumetti e altre lettere.
\end{quote}
#+end_export

**** Progetti
#+name: projects-jinja-latex
#+begin_src latex :results output
{% for project in projects %}
\cvevent{ {%- if project.name -%}{{project.name}}{%- endif -%} }{ {%- if project.description -%}{{project.description}}{%- endif -%} }{ {%- if project.when -%}{{project.when}}{%- endif -%} }{}

\begin{itemize}
\item \href{ {{project.link.href}} }{\fa{{ project.link.icon }} {{ project.link.text }}}
\end{itemize}
\vspace{.2cm}

{% for tag in project.tags %}
\cvtag{ {{tag}} }
{% endfor %}
{% if not loop.last %}
\par\divider
{% endif %}
{% endfor %}
#+end_src

Renderizziamo tutti i progetti:

#+name: projects-latex
#+begin_src python :session cv-venv :results output latex :var templ=projects-jinja-latex :var ctx=projects-json()
try:
    import jinja2
    import json
except Exception as e:
    print(e)

projects=json.loads(ctx)
env = jinja2.Environment()
env.trim_blocks = True
env.lstrim_blocks = True
template = env.from_string(templ)
print(template.render(projects=projects))
#+end_src

#+RESULTS: projects-latex
#+begin_export latex
\cvevent{Esrafel}{Software for least-squares fitting of ESR/EPR spectra with Monte Carlo methods}{Marzo 2020 - Marzo 2022}{}

\begin{itemize}
\item \href{ https://github.com/gicrisf/esrafel }{\faGithub gicrisf/esrafel}
\end{itemize}
\vspace{.2cm}

\cvtag{ Desktop dev. }
\cvtag{ Rust }
\cvtag{ GTK }
\cvtag{ Spettroscopia }
\par\divider
\cvevent{Zhuia}{An elegant but still playful theme for Zola}{Feb. 2022 - Marzo 2022}{}

\begin{itemize}
\item \href{ https://github.com/gicrisf/zhuia }{\faGithub gicrisf/zhuia}
\end{itemize}
\vspace{.2cm}

\cvtag{ Web dev. }
\cvtag{ Rust }
\cvtag{ Zola }
\cvtag{ Tera }
\cvtag{ Liquid }
\cvtag{ Jinja2 }
\par\divider
\cvevent{3D renders}{Bio/Chem molecular renders for fun and blogging}{}{}

\begin{itemize}
\item \href{ https://unsplash.com/@gicrisf }{\faUnsplash @gicrisf}
\end{itemize}
\vspace{.2cm}

\cvtag{ Grafica }
\cvtag{ Chimica }
\cvtag{ GIMP }
\cvtag{ VMD }
#+end_export

**** Seminari
#+name: seminari-jinja-latex
#+begin_src latex
{% for seminario in seminari %}
\cvevent{ {%- if seminario.name -%} {{seminario.name}}{%- endif -%} }{ {%- if seminario.where -%} {{seminario.where}}{%- endif -%} }{ {%- if seminario.when -%} {{seminario.when}}{%- endif -%} }{}

{% if not loop.last %}
\par\divider
{% endif %}
{% endfor %}
#+end_src

Renderizziamo tutti i progetti:

#+name: seminari-latex
#+begin_src python :session cv-venv :results output latex :var templ=seminari-jinja-latex :var ctx=seminari-json()
seminari=json.loads(ctx)
env = jinja2.Environment()
env.trim_blocks = True
env.lstrim_blocks = True
template = env.from_string(templ)
print(template.render(seminari=seminari))
#+end_src

#+RESULTS: seminari-latex
#+begin_export latex
\cvevent{Festival della Scienza Medica}{Palazzo Re Enzo - piazza Nettuno 1 - Bologna}{Anni: 2016 - 2017 - 2018 - 2019}{}

\par\divider
\cvevent{18° Congresso Nazionale Sitox}{Savoia Hotel Regency - Via del Pilastro 2 - 40127 Bologna}{10 Apr. 2018 - 13 Apr. 2018}{}

\par\divider
\cvevent{Driving the development of bio-based polymers with molecular simulation}{Chemistry World Webinar}{13 Apr. 2022}{}

\par\divider
\cvevent{Accelerating first-in-class and best-in-class programs using a large-scale digital chemistry strategy}{Chemistry World Webinar}{24 Maggio 2022}{}
#+end_export

*** Column 2
**** Skills
Stampa le keywords ed aggiungi un leggero spazio verticale ogni tre tag.

#+name: skills-jinja-latex
#+begin_src latex
{% for skill in skills.keywords %}
\cvtag { {{skill}} }
{% if skill | length >= 14 %}

\vspace{+.1cm}
{% endif %}
{% if not loop.last %}
{% if loop.index % 3 == 0 %}

\vspace{+.1cm}

{% endif %}
{% endif %}
{% endfor %}
#+end_src

Renderizziamo:

#+name: skills-latex
#+begin_src python :session cv-venv :results output latex :var templ=skills-jinja-latex :var ctx=general-skills-json()
skills=json.loads(ctx)
env = jinja2.Environment()
env.trim_blocks = True
env.lstrim_blocks = True
template = env.from_string(templ)
print(template.render(skills=skills))
#+end_src

#+RESULTS: skills-latex
#+begin_export latex
\cvtag { Pharmaceutical chemistry }

\vspace{+.1cm}
\cvtag { Spectroscopy }
\cvtag { Programming }

\vspace{+.1cm}

\cvtag { Web dev. }
\cvtag { Desktop dev. }
\cvtag { Data viz. }
#+end_export

**** Experiences
#+name: exps-jinja-latex
#+begin_src latex
{% for exp in exps %}
\cvevent{ {{exp.name}} }{ {{ exp.where }} }{ {{ exp.when }} }{}
{% if not loop.last %}

\par\divider

{% endif %}
{% endfor %}
#+end_src

Renderizziamo:

#+name: exps-latex
#+begin_src python :session cv-venv :results output latex :var templ=exps-jinja-latex :var ctx=exps-json()
exps=json.loads(ctx)
env = jinja2.Environment()
env.trim_blocks = True
env.lstrim_blocks = True
template = env.from_string(templ)
print(template.render(exps=exps))
#+end_src

#+RESULTS: exps-latex
#+begin_export latex
\cvevent{ Tirocinio in Farmacia Ospedaliera }{ Ospedale Gravina di Caltagirone }{ Ottobre 2020 - Luglio 2021 }{}

\par\divider

\cvevent{ Tirocinio per tesi sperimentale }{ Dipartimento di "Chimica Giacomo Ciamician" - Unibo }{ Ottobre 2019 - Maggio 2020 }{}
#+end_export

**** Education
TODO manage più commenti (comments)

#+name: edu-jinja-latex
#+begin_src latex
{% for event in edu|reverse %}
\cvevent{ {%- if event.name -%}{{ event.name }}{%- endif -%} }{ {%- if event.where -%}{{ event.where }}{%- endif -%} }{ {%- if event.when -%}{{ event.when }}{%- endif -%} }{}
{% if event.comment -%}
\begin{itemize}
\item {{ event.comment }}
\end{itemize}
{% endif %}

\divider
{% endfor %}
#+end_src

Renderizziamo:

#+name: edu-latex
#+begin_src python :session cv-venv :results output latex :var templ=edu-jinja-latex :var ctx=edu-json()
edu=json.loads(ctx)
env = jinja2.Environment()
env.trim_blocks = True
env.lstrim_blocks = True
template = env.from_string(templ)
print(template.render(edu=edu))
#+end_src

#+RESULTS: edu-latex
#+begin_export latex
\cvevent{Summer School in Pharmaceutical Analysis}{Campus di Rimini - Palazzo Ruffi-Briolini}{18 Sett. 2017 - 20 Sett. 2017}{}
\begin{itemize}
\item Advanced Analytical Methodologies for Adsorption, Distribution, Metabolism, Excretion and Toxicity (ADMET) Studies
\end{itemize}

\divider
\cvevent{Magistrale a ciclo unico in Chimica e Tecnologia Farmaceutiche}{Dipartimento di Farmacia e Biotecnologie FABIT - Università di Bologna}{Sett. 2014 - In corso}{}

\divider
\cvevent{Diploma Liceo Scientifico}{Liceo Scientifico E. Majorana - Caltagirone}{Sett. 2009 - Giugno 2014}{}

\divider
#+end_export

**** Langs
#+name: langs-jinja-latex
#+begin_src latex
{% for lang in langs %}
\cvskill { {{lang.name}} }{ {{lang.level}} }
{% if not loop.last %}
\divider
{% endif %}
{% endfor %}
#+end_src

Renderizziamo:

#+name: langs-latex
#+begin_src python :session cv-venv :results output latex :var templ=langs-jinja-latex :var ctx=langs-json()
langs=json.loads(ctx)
env = jinja2.Environment()
env.trim_blocks = True
env.lstrim_blocks = True
template = env.from_string(templ)
print(template.render(langs=langs))
#+end_src

#+RESULTS: langs-latex
#+begin_export latex
\cvskill { Italiano }{ 5 }
\divider
\cvskill { Inglese }{ 4 }
\divider
\cvskill { Francese }{ 1 }
#+end_export

* TODO Markdown
Qui potrei usare ox-hugo
* TODO JSON
Posso esportare tutti i dati con un =json.dumps= e fare il tangling.
Posso anche adattare i dati allo schema JSON di JSON Resume.
